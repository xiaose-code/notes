# 让自己习惯C++

# 条款1：视C++为一个语言联邦

条款1中提到了将C++看作为一个“语言联邦”的概念。具体来说，“语言联邦”是指将C++看作由多种不同的子语言组成的联邦。每种子语言都有自己的惯用法、工具和库，可以用来解决特定的问题。因此，C++程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。 这个概念的含义可以从以下几个方面来解释：

1. 多种子语言：C++由多种子语言组成，每种子语言都有自己的规则、习惯和约定。例如，面向对象编程（OOP）子语言、模板元编程（TMP）子语言等。这些子语言都有自己的语法和语义，可以用来解决特定的问题。
2. 惯用法和工具：每种子语言都有自己的惯用法和工具。例如，**OOP中常用的类、继承、多态等概念，以及与之对应的工具和库**，**如STL、Boost等**。熟悉这些惯用法和工具可以提高程序员的开发效率和代码质量。
3. 选择最适合的子语言：C++程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。例如，**如果要处理大量的数值计算，可以选择使用TMP子语言中的模板元编程技术，来提高程序的性能**；**如果要实现一些复杂的数据结构和算法，可以使用STL等库来简化代码**。

总的来说，可以将C++视为一个由4个次语言组成的联邦而非单一语言：

1. C，说到底C++仍是以C为基础。
2. object-oriented C++，包括封装、继承、多态等面向对象设计。
3. template C++，泛型编程，衍生出模板元编程（在各个新标准中逐步完善）。
4. STL，包括容器、迭代器、算法与函数对象。



# 条款2：尽量以const、enum、inline替换#define

条款2中提到了尽量使用`const`、`enum`和`inline`来替代`#define`的概念。具体来说，`#define`是一种预处理指令，可以将一个标识符定义为一个值或一个字符串。而`const`、`enum`和`inline`都是C++语言中的关键字，也可以用于定义常量和函数。以下是对这个条款的一些解释：

1. `#define`的缺点：使用`#define`定义常量存在一些缺点，**例如它不会进行类型检查，容易引起意外的副作用，也不会被语法检查工具正确地处理**。
2. `const`的优点：使用`const`定义常量可以避免`#define`的缺点。`const`定义的常量有类型，可以被编译器检查和优化，也可以被调试器和其他工具正确地处理。
3. `enum`的优点：如果要定义一系列相关的常量，可以使用`enum`枚举类型。`enum`定义的常量有类型，可以被编译器检查和优化，同时也可以提高代码的可读性和可维护性。
4. `inline`的优点：如果要定义一个简单的函数或者函数模板，可以使用`inline`关键字。`inline`函数在编译时会被展开，从而避免了函数调用的开销。同时，`inline`函数也可以提高代码的可读性和可维护性。

\#define可以用来定义一些变量、函数，但它只是一方面单纯的文本替换，并且没有任何类型检查，导致容易引起莫名其妙的问题，另一方面预处理后已经消失，编译链接过程中没有其符号信息，出问题时无法定位到它。

```C++
#define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))

int a=5,b=0;
CALL_WITH_MAX(++a,b);
CALL_WITH_MAX(++a,b+10);
```

即使上文的宏已经仔细地为所有参数添加小括号，仍然出现了问题：第一次调用中a被累加两次，第二次调用中a被累加一次。

> **`CALL_WITH_MAX(++a,b)`在展开后变成了`f((++a)>(b)?(++a):(b))`，其中`a`的值被多次递增。**
>
> **而`CALL_WITH_MAX(++a,b+10)`在展开后变成了`f((++a)>(b+10)?(++a):(b+10))`，其中`a`的值也被多次递增。**
>
> 因此，这两个调用会导致`a`的值被递增多次，结果可能不是我们所期望的。
>
> **为了避免这个问题，更加可预测并且类型安全的写法是，可以使用函数模板来替代`#define`宏。使用const对象（对于一系列常量，使用枚举或枚举类，而不是一系列#define）**
>
> 例如，可以定义一个`template<typename T> inline void callWithMax(const T& a, const T& b)`函数来替代`CALL_WITH_MAX`宏。
>
> 这样做不仅可以避免上述问题，还可以提高代码的可读性和可维护性。例如：
>
> ```C++
> template<typename T>
> inline void callWithMax(const T& a, const T& b)
> {
> f(a > b ? a : b);
> }
> int a = 5, b = 0;
> callWithMax(++a, b);
> callWithMax(++a, b + 10);
> // 这段代码中，a的值只会被递增一次，符合我们的预期。
> // 不过inline目前主要指多重定义而非内联
> ```



# 条款3：尽可能使用const

条款3中提到了尽可能使用`const`的概念。具体来说，`const`是C++语言中的关键字，用于定义常量。以下是对这个条款的一些解释：

1. `const`的作用：使用`const`可以将变量定义为常量，即不能被修改。常量可以提高代码的可读性和可维护性，同时也可以避免意外的修改导致的错误。
2. `const`的使用场景：在C++中，`const`可以用于定义常量、函数参数和函数返回值等。使用`const`定义常量时，可以使用`const`关键字加上变量的类型，例如`const int MAX_SIZE = 1024;`。使用`const`定义函数参数时，可以在参数类型前加上`const`关键字，例如`void foo(const std::string& str);`。使用`const`定义函数返回值时，可以在函数声明和定义中返回类型前加上`const`关键字，例如`const std::string& foo() const;`。
3. `const`的作用域：在C++中，`const`变量和`const`函数的作用域与普通变量和函数的作用域相同。如果`const`变量或`const`函数在某个作用域内定义，那么它们只能在该作用域内使用。
4. `const`和指针：使用指针时，`const`可以用于限定指针本身或指针所指向的内容是否可修改。例如，`const int* p`表示指向`const int`类型的指针，即指针所指向的内容不能被修改；`int* const p`表示指向`int`类型的`const`指针，即指针本身不能被修改。另外，`const`还可以同时限定指针本身和指针所指向的内容是否可修改，例如`const int* const p`表示指向`const int`类型的`const`指针。

```C++
char greeting[] = "Hello";
char* p1 = greeting;
const char* p2 = greeting;       //被指物不可修改
char* const p3 = greeting        //指针不可修改
const char* const p4 = greeting; //皆不可修改
```



真正威力强大的用法是面对函数声明时，const可以和函数返回值、各参数、成员函数自身产生关联。例如令函数返回const，往往可以降低因用户错误而造成的意外，又不至于放弃安全性和高效性。

```C++
class Rational{...};
const Rational operator*(const Rational& lhs,const Rational& rhs);
//上述写法可以避免用户写出 a*b = c
```

对于成员函数自身的const，编译器强制实施bitwise const，即强制不能修改任何成员变量。**这意味着，在const成员函数中，即使我们使用了mutable关键字，也不能修改任何非mutable成员变量。**但实际上很多情况下我们需要的是logical const，**即const成员函数也应该可以修改某些客户不可见的数据，这时可以用mutable成员变量来绕过const成员函数的限制。**

例如对于一个文本块的对象而言，其内部很可能存在高速缓存；对于查询文本块长度这样的const操作，仍然需要更新高速缓存：

```C++
class TextBlock{
public:
  std::size_t length() const;
private:
  char *pText;
  mutable std::size_t text_length;
  mutable bool length_is_valid;
};

std::size_t TextBlock::length() const{
  if(!length_is_valid){
    text_length = std::strlen(pText);
    length_is_valid = true;
  }
  return text_length;
};
```

这是一个名为`TextBlock`的类，其中包含一个私有成员变量`char *pText`，表示一个C风格的字符串。该类还包含了两个`mutable`类型的私有成员变量`std::size_t text_length`和`bool length_is_valid`，用于缓存字符串长度和标记长度是否已经被计算。该类还定义了一个公有成员函数`std::size_t length() const`，用于获取字符串的长度。下面是对该类的解释：

1. `TextBlock`类中的`char *pText`表示一个C风格的字符串，但是没有提供构造函数或析构函数来管理字符串的内存，这样会存在内存泄漏的风险，需要在类中添加构造函数和析构函数来管理字符串的内存。
2. **`TextBlock`类中的`text_length`和`length_is_valid`成员变量被声明为`mutable`类型，表示即使在`const`函数中也可以被修改。**这是==因为`length()`函数需要计算字符串的长度，如果多次调用该函数，每次都重新计算字符串长度会浪费时间，因此使用`mutable`类型的成员变量缓存计算结果，避免重复计算。==
3. `TextBlock`类中的`length()`函数是一个`const`函数，表示该函数不会修改类的成员变量，因此可以在`const`对象中调用。在函数中使用`!length_is_valid`判断是否需要重新计算字符串长度，如果需要计算，则调用`std::strlen(pText)`计算字符串长度，再将计算结果缓存到`text_length`中，并将`length_is_valid`标记为`true`。最后，返回缓存的字符串长度。
4. 由于`TextBlock`类中的`pText`变量是一个C风格的字符串，并且没有提供构造函数和析构函数来管理内存，因此在使用该类时需要特别注意内存泄漏的问题。可以通过使用`std::string`等C++标准库提供的字符串类型来避免这个问题。



C++中两个函数如果只是常量性不同，也可以重载。当const成员函数与非const成员函数有着实质等价的实现时，为了避免冗余，可以令non-const版本调用const版本：

```C++
class TextBlock{
public:
  const char& operator[](std::size_t position) const{
    ...
  }
  char& operator[](std::size_t position){
    return const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
  }
};
//后者首先将自身转换为const对象
//随后调用const成员函数，返回const引用
//最后转换为non-const引用
```

这是一个名为`TextBlock`的类，其中定义了两个下标运算符`operator[]`，用于访问类中的字符数据。第一个下标运算符是一个`const`成员函数，返回一个`const char&`类型的引用，表示在指定位置的字符数据。第二个下标运算符是一个非`const`成员函数，返回一个`char&`类型的引用，表示在指定位置的字符数据。下面是对该代码的解释：

1. 第一个下标运算符是一个`const`成员函数，表示该函数不会修改类的成员变量。在函数中，使用`const`关键字修饰函数的返回值，表示返回的是一个常量引用。该函数返回指定位置的字符数据，并且由于返回的是一个常量引用，因此客户端无法通过该函数修改类的成员变量。
2. 第二个下标运算符是一个非`const`成员函数，表示该函数可以修改类的成员变量。在函数中，我们使用了`const_cast`和`static_cast`两个操作符，将该函数转换成了一个`const`成员函数的调用。**具体来说，我们首先使用`static_cast<const TextBlock&>(*this)`将当前对象转换成一个`const TextBlock&`类型的对象，然后调用第一个下标运算符，返回在指定位置的字符数据的常量引用。接着，我们使用`const_cast<char&>`将常量引用转换为一个非常量引用，从而使得客户端可以通过该函数修改类的成员变量。**==需要注意的是，这种使用const_cast的方式是有风险的，因为它可以绕过函数的const限制，可能导致程序的未定义行为和内存安全问题。==
3. 如果我们希望在第二个下标运算符中修改一些客户端不可见的数据，可以使用mutable关键字修饰一个成员变量，避免使用const_cast绕过const限制。



# 条款4：确定对象被使用前已先被初始化

条款4的意思是，在使用一个对象之前，必须确保该对象已经被正确地初始化。如果一个对象没有被正确地初始化，那么它的行为是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。 **在C++中，对象的初始化方式有多种，包括默认初始化、值初始化、直接初始化、拷贝初始化等**。不同的初始化方式会对对象的状态产生不同的影响。为了保证对象被正确地初始化，我们应该遵循以下几个原则：

1. **明确对象的初始化方式。**在定义对象时，应该清楚地指定对象的初始化方式，避免使用未初始化的对象。
2. **尽可能使用构造函数进行初始化。**构造函数是一种专门用于初始化对象的函数，可以保证对象的状态正确。因此，在定义对象时，应该尽可能使用构造函数进行初始化。
3. **避免使用未定义的对象。**在使用对象之前，应该确保对象已经被正确地初始化。如果不确定对象是否已经被初始化，就应该避免使用该对象。
4. **避免使用未定义的成员变量。**在定义类时，应该确保类的成员变量都被正确地初始化。如果一个成员变量没有被正确地初始化，那么该成员变量的行为也是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。

C++中变量并非一定会进行初始化。最佳处理办法是：对于内置类型必须手动初始化，而对于用户定义的对象，在使用对象前将其初始化（责任落在构造函数上）。

 构造函数包含成员初值列与函数体。

1. 最好使用成员初始列的初始化而非函数体内的赋值，否则对象会在成员初始列的步骤中进行默认初始化，再在赋值的过程中进行拷贝，成本增高。
2. 成员初始列的排列顺序应与在类中的声明次序一致，因为成员初始化顺序只与后者有关，前者若与后者不一致的话可能导致误解。

只剩最后一个难点：函数内的静态变量称为local静态变量，其他的都是non-local；而不同编译单元（一个编译单元指产出单一目标文件的源码们）内定义的non-local静态对象的初始化顺序并未规定。倘若存在这样的两个变量a和b，且b的初始化需要使用a，如果a尚未初始化就被b使用了，显然程序会出错。

> **local静态变量指的是函数内定义的静态变量，只在函数的作用域内可见；**
>
> **而non-local静态变量指的是在全局作用域或命名空间内定义的静态变量，可以被多个函数使用。**
>
> 在C++中，对于non-local静态变量的初始化顺序并没有严格的规定。这意味着，如果存在两个non-local静态变量a和b，且b的初始化需要使用a，那么如果a尚未初始化就被b使用了，就会导致程序出错。**这是因为，如果a尚未初始化，那么它的值是不确定的，可能是一个随机值，也可能是0或其他默认值。如果b在使用a之前被初始化，那么它使用的a的值是不确定的，这可能会导致程序出错。**
>
> 为了避免这种问题，我们可以采用一些编程技巧和约定来确保non-local静态变量的正确初始化顺序。**例如，可以使用单例模式等设计模式**来确保对象的初始化顺序；或者可以将non-local静态变量的初始化工作放在函数内部，以确保它们在第一次使用之前被正确地初始化。此外，我们还可以使用编译器提供的一些选项来控制non-local静态变量的初始化顺序，但这种方法并不是跨平台的，可能会导致代码的可移植性问题。

解决方法也很简单：将每个non-local静态变量移到自己的专属函数内，这些函数返回该静态变量的引用，用户使用这些函数而非直接使用变量（类似单例模式）。至此，non-local静态变量被local静态变量取代。

```C++
class FileSystem{...};
FileSystem& tfs(){
  static FileSystem fs;
  return fs;
}
class Directory{...};
Directory::Directory(...){
    ...
   std::size_t disks = tfs().num_disks();
   ...
}
```

这段代码定义了一个名为`FileSystem`的类和一个名为`tfs()`的函数，以及另一个名为`Directory`的类和它的一个构造函数。

在`tfs()`函数内部，定义了一个名为`fs`的静态对象，它是`FileSystem`类的一个实例，并且返回了这个静态对象的引用。

在`Directory`类的构造函数内部，首先执行了一些初始化工作，然后通过调用`tfs()`函数获取到了`FileSystem`对象的引用，并通过该引用调用了`num_disks()`函数，将返回值存储在了一个名为`disks`的变量中。 

由于`tfs()`函数内部定义的`fs`对象是一个静态对象，因此它在程序运行期间只会被创建一次，并且在整个程序的生命周期内都存在。

每次调用`tfs()`函数时，都会返回同一个静态对象的引用。这种方式可以保证`FileSystem`类的实例只有一个，并且可以在全局范围内被访问。

在`Directory`类的构造函数内部，通过调用`tfs()`函数获取到了`FileSystem`对象的引用，并且调用了它的`num_disks()`函数，这种方式可以确保`Directory`类的实例可以访问到全局唯一的`FileSystem`对象，并且可以获取到该对象的属性和方法。 

总之，这段代码通过使用静态变量和函数，实现了一个全局唯一的`FileSystem`对象，并且可以在其他类的构造函数中使用该对象，从而避免了对象的多次创建和初始化，提高了程序的效率和可读性。同时，该代码还展示了C++中静态变量和静态函数的用法，可以作为学习C++语言的参考。