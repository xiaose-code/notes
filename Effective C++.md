# Effective C++

# 条款1：视C++为一个语言联邦

条款1中提到了将C++看作为一个“语言联邦”的概念。具体来说，“语言联邦”是指将C++看作由多种不同的子语言组成的联邦。每种子语言都有自己的惯用法、工具和库，可以用来解决特定的问题。因此，C++程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。 这个概念的含义可以从以下几个方面来解释：

1. 多种子语言：C++由多种子语言组成，每种子语言都有自己的规则、习惯和约定。例如，面向对象编程（OOP）子语言、模板元编程（TMP）子语言等。这些子语言都有自己的语法和语义，可以用来解决特定的问题。
2. 惯用法和工具：每种子语言都有自己的惯用法和工具。例如，**OOP中常用的类、继承、多态等概念，以及与之对应的工具和库**，**如STL、Boost等**。熟悉这些惯用法和工具可以提高程序员的开发效率和代码质量。
3. 选择最适合的子语言：C++程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。例如，**如果要处理大量的数值计算，可以选择使用TMP子语言中的模板元编程技术，来提高程序的性能**；**如果要实现一些复杂的数据结构和算法，可以使用STL等库来简化代码**。

总的来说，可以将C++视为一个由4个次语言组成的联邦而非单一语言：

1. C，说到底C++仍是以C为基础。
2. object-oriented C++，包括封装、继承、多态等面向对象设计。
3. template C++，泛型编程，衍生出模板元编程（在各个新标准中逐步完善）。
4. STL，包括容器、迭代器、算法与函数对象。

------

# 条款2：尽量以const、enum、inline替换#define

条款2中提到了尽量使用`const`、`enum`和`inline`来替代`#define`的概念。具体来说，`#define`是一种预处理指令，可以将一个标识符定义为一个值或一个字符串。而`const`、`enum`和`inline`都是C++语言中的关键字，也可以用于定义常量和函数。以下是对这个条款的一些解释：

1. `#define`的缺点：使用`#define`定义常量存在一些缺点，**例如它不会进行类型检查，容易引起意外的副作用，也不会被语法检查工具正确地处理**。
2. `const`的优点：使用`const`定义常量可以避免`#define`的缺点。`const`定义的常量有类型，可以被编译器检查和优化，也可以被调试器和其他工具正确地处理。
3. `enum`的优点：如果要定义一系列相关的常量，可以使用`enum`枚举类型。`enum`定义的常量有类型，可以被编译器检查和优化，同时也可以提高代码的可读性和可维护性。
4. `inline`的优点：如果要定义一个简单的函数或者函数模板，可以使用`inline`关键字。`inline`函数在编译时会被展开，从而避免了函数调用的开销。同时，`inline`函数也可以提高代码的可读性和可维护性。

\#define可以用来定义一些变量、函数，但它只是一方面单纯的文本替换，并且没有任何类型检查，导致容易引起莫名其妙的问题，另一方面预处理后已经消失，编译链接过程中没有其符号信息，出问题时无法定位到它。

```C++
#define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))

int a=5,b=0;
CALL_WITH_MAX(++a,b);
CALL_WITH_MAX(++a,b+10);
```

即使上文的宏已经仔细地为所有参数添加小括号，仍然出现了问题：第一次调用中a被累加两次，第二次调用中a被累加一次。

> **`CALL_WITH_MAX(++a,b)`在展开后变成了`f((++a)>(b)?(++a):(b))`，其中`a`的值被多次递增。**
>
> **而`CALL_WITH_MAX(++a,b+10)`在展开后变成了`f((++a)>(b+10)?(++a):(b+10))`，其中`a`的值也被多次递增。**
>
> 因此，这两个调用会导致`a`的值被递增多次，结果可能不是我们所期望的。
>
> **为了避免这个问题，更加可预测并且类型安全的写法是，可以使用函数模板来替代`#define`宏。使用const对象（对于一系列常量，使用枚举或枚举类，而不是一系列#define）**
>
> 例如，可以定义一个`template<typename T> inline void callWithMax(const T& a, const T& b)`函数来替代`CALL_WITH_MAX`宏。
>
> 这样做不仅可以避免上述问题，还可以提高代码的可读性和可维护性。例如：
>
> ```C++
> template<typename T>
> inline void callWithMax(const T& a, const T& b)
> {
>  f(a > b ? a : b);
> }
> int a = 5, b = 0;
> callWithMax(++a, b);
> callWithMax(++a, b + 10);
> // 这段代码中，a的值只会被递增一次，符合我们的预期。
> // 不过inline目前主要指多重定义而非内联
> ```

------

# 条款3：尽可能使用const

条款3中提到了尽可能使用`const`的概念。具体来说，`const`是C++语言中的关键字，用于定义常量。以下是对这个条款的一些解释：

1. `const`的作用：使用`const`可以将变量定义为常量，即不能被修改。常量可以提高代码的可读性和可维护性，同时也可以避免意外的修改导致的错误。
2. `const`的使用场景：在C++中，`const`可以用于定义常量、函数参数和函数返回值等。使用`const`定义常量时，可以使用`const`关键字加上变量的类型，例如`const int MAX_SIZE = 1024;`。使用`const`定义函数参数时，可以在参数类型前加上`const`关键字，例如`void foo(const std::string& str);`。使用`const`定义函数返回值时，可以在函数声明和定义中返回类型前加上`const`关键字，例如`const std::string& foo() const;`。
3. `const`的作用域：在C++中，`const`变量和`const`函数的作用域与普通变量和函数的作用域相同。如果`const`变量或`const`函数在某个作用域内定义，那么它们只能在该作用域内使用。
4. `const`和指针：使用指针时，`const`可以用于限定指针本身或指针所指向的内容是否可修改。例如，`const int* p`表示指向`const int`类型的指针，即指针所指向的内容不能被修改；`int* const p`表示指向`int`类型的`const`指针，即指针本身不能被修改。另外，`const`还可以同时限定指针本身和指针所指向的内容是否可修改，例如`const int* const p`表示指向`const int`类型的`const`指针。

```C++
char greeting[] = "Hello";
char* p1 = greeting;
const char* p2 = greeting;       //被指物不可修改
char* const p3 = greeting        //指针不可修改
const char* const p4 = greeting; //皆不可修改
```



真正威力强大的用法是面对函数声明时，const可以和函数返回值、各参数、成员函数自身产生关联。例如令函数返回const，往往可以降低因用户错误而造成的意外，又不至于放弃安全性和高效性。

```C++
class Rational{...};
const Rational operator*(const Rational& lhs,const Rational& rhs);
//上述写法可以避免用户写出 a*b = c
```

对于成员函数自身的const，编译器强制实施bitwise const，即强制不能修改任何成员变量。**这意味着，在const成员函数中，即使我们使用了mutable关键字，也不能修改任何非mutable成员变量。**但实际上很多情况下我们需要的是logical const，**即const成员函数也应该可以修改某些客户不可见的数据，这时可以用mutable成员变量来绕过const成员函数的限制。**

例如对于一个文本块的对象而言，其内部很可能存在高速缓存；对于查询文本块长度这样的const操作，仍然需要更新高速缓存：

```C++
class TextBlock{
public:
  std::size_t length() const;
private:
  char *pText;
  mutable std::size_t text_length;
  mutable bool length_is_valid;
};

std::size_t TextBlock::length() const{
  if(!length_is_valid){
    text_length = std::strlen(pText);
    length_is_valid = true;
  }
  return text_length;
};
```

这是一个名为`TextBlock`的类，其中包含一个私有成员变量`char *pText`，表示一个C风格的字符串。该类还包含了两个`mutable`类型的私有成员变量`std::size_t text_length`和`bool length_is_valid`，用于缓存字符串长度和标记长度是否已经被计算。该类还定义了一个公有成员函数`std::size_t length() const`，用于获取字符串的长度。下面是对该类的解释：

1. `TextBlock`类中的`char *pText`表示一个C风格的字符串，但是没有提供构造函数或析构函数来管理字符串的内存，这样会存在内存泄漏的风险，需要在类中添加构造函数和析构函数来管理字符串的内存。
2. **`TextBlock`类中的`text_length`和`length_is_valid`成员变量被声明为`mutable`类型，表示即使在`const`函数中也可以被修改。**这是==因为`length()`函数需要计算字符串的长度，如果多次调用该函数，每次都重新计算字符串长度会浪费时间，因此使用`mutable`类型的成员变量缓存计算结果，避免重复计算。==
3. `TextBlock`类中的`length()`函数是一个`const`函数，表示该函数不会修改类的成员变量，因此可以在`const`对象中调用。在函数中使用`!length_is_valid`判断是否需要重新计算字符串长度，如果需要计算，则调用`std::strlen(pText)`计算字符串长度，再将计算结果缓存到`text_length`中，并将`length_is_valid`标记为`true`。最后，返回缓存的字符串长度。
4. 由于`TextBlock`类中的`pText`变量是一个C风格的字符串，并且没有提供构造函数和析构函数来管理内存，因此在使用该类时需要特别注意内存泄漏的问题。可以通过使用`std::string`等C++标准库提供的字符串类型来避免这个问题。



C++中两个函数如果只是常量性不同，也可以重载。当const成员函数与非const成员函数有着实质等价的实现时，为了避免冗余，可以令non-const版本调用const版本：

```C++
class TextBlock{
public:
  const char& operator[](std::size_t position) const{
    ...
  }
  char& operator[](std::size_t position){
    return const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
  }
};
//后者首先将自身转换为const对象
//随后调用const成员函数，返回const引用
//最后转换为non-const引用
```

这是一个名为`TextBlock`的类，其中定义了两个下标运算符`operator[]`，用于访问类中的字符数据。第一个下标运算符是一个`const`成员函数，返回一个`const char&`类型的引用，表示在指定位置的字符数据。第二个下标运算符是一个非`const`成员函数，返回一个`char&`类型的引用，表示在指定位置的字符数据。下面是对该代码的解释：

1. 第一个下标运算符是一个`const`成员函数，表示该函数不会修改类的成员变量。在函数中，使用`const`关键字修饰函数的返回值，表示返回的是一个常量引用。该函数返回指定位置的字符数据，并且由于返回的是一个常量引用，因此客户端无法通过该函数修改类的成员变量。
2. 第二个下标运算符是一个非`const`成员函数，表示该函数可以修改类的成员变量。在函数中，我们使用了`const_cast`和`static_cast`两个操作符，将该函数转换成了一个`const`成员函数的调用。**具体来说，我们首先使用`static_cast<const TextBlock&>(*this)`将当前对象转换成一个`const TextBlock&`类型的对象，然后调用第一个下标运算符，返回在指定位置的字符数据的常量引用。接着，我们使用`const_cast<char&>`将常量引用转换为一个非常量引用，从而使得客户端可以通过该函数修改类的成员变量。**==需要注意的是，这种使用const_cast的方式是有风险的，因为它可以绕过函数的const限制，可能导致程序的未定义行为和内存安全问题。==
3. 如果我们希望在第二个下标运算符中修改一些客户端不可见的数据，可以使用mutable关键字修饰一个成员变量，避免使用const_cast绕过const限制。

------

# 条款4：确定对象被使用前已先被初始化

条款4的意思是，在使用一个对象之前，必须确保该对象已经被正确地初始化。如果一个对象没有被正确地初始化，那么它的行为是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。 **在C++中，对象的初始化方式有多种，包括默认初始化、值初始化、直接初始化、拷贝初始化等**。不同的初始化方式会对对象的状态产生不同的影响。为了保证对象被正确地初始化，我们应该遵循以下几个原则：

1. **明确对象的初始化方式。**在定义对象时，应该清楚地指定对象的初始化方式，避免使用未初始化的对象。
2. **尽可能使用构造函数进行初始化。**构造函数是一种专门用于初始化对象的函数，可以保证对象的状态正确。因此，在定义对象时，应该尽可能使用构造函数进行初始化。
3. **避免使用未定义的对象。**在使用对象之前，应该确保对象已经被正确地初始化。如果不确定对象是否已经被初始化，就应该避免使用该对象。
4. **避免使用未定义的成员变量。**在定义类时，应该确保类的成员变量都被正确地初始化。如果一个成员变量没有被正确地初始化，那么该成员变量的行为也是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。

C++中变量并非一定会进行初始化。最佳处理办法是：对于内置类型必须手动初始化，而对于用户定义的对象，在使用对象前将其初始化（责任落在构造函数上）。

 构造函数包含成员初值列与函数体。

1. 最好使用成员初始列的初始化而非函数体内的赋值，否则对象会在成员初始列的步骤中进行默认初始化，再在赋值的过程中进行拷贝，成本增高。
2. 成员初始列的排列顺序应与在类中的声明次序一致，因为成员初始化顺序只与后者有关，前者若与后者不一致的话可能导致误解。

只剩最后一个难点：函数内的静态变量称为local静态变量，其他的都是non-local；而不同编译单元（一个编译单元指产出单一目标文件的源码们）内定义的non-local静态对象的初始化顺序并未规定。倘若存在这样的两个变量a和b，且b的初始化需要使用a，如果a尚未初始化就被b使用了，显然程序会出错。

> **local静态变量指的是函数内定义的静态变量，只在函数的作用域内可见；**
>
> **而non-local静态变量指的是在全局作用域或命名空间内定义的静态变量，可以被多个函数使用。**
>
> 在C++中，对于non-local静态变量的初始化顺序并没有严格的规定。这意味着，如果存在两个non-local静态变量a和b，且b的初始化需要使用a，那么如果a尚未初始化就被b使用了，就会导致程序出错。**这是因为，如果a尚未初始化，那么它的值是不确定的，可能是一个随机值，也可能是0或其他默认值。如果b在使用a之前被初始化，那么它使用的a的值是不确定的，这可能会导致程序出错。**
>
> 为了避免这种问题，我们可以采用一些编程技巧和约定来确保non-local静态变量的正确初始化顺序。**例如，可以使用单例模式等设计模式**来确保对象的初始化顺序；或者可以将non-local静态变量的初始化工作放在函数内部，以确保它们在第一次使用之前被正确地初始化。此外，我们还可以使用编译器提供的一些选项来控制non-local静态变量的初始化顺序，但这种方法并不是跨平台的，可能会导致代码的可移植性问题。

解决方法也很简单：将每个non-local静态变量移到自己的专属函数内，这些函数返回该静态变量的引用，用户使用这些函数而非直接使用变量（类似单例模式）。至此，non-local静态变量被local静态变量取代。

```C++
class FileSystem{...};
FileSystem& tfs(){
  static FileSystem fs;
  return fs;
}
class Directory{...};
Directory::Directory(...){
    ...
   std::size_t disks = tfs().num_disks();
   ...
}
```

这段代码定义了一个名为`FileSystem`的类和一个名为`tfs()`的函数，以及另一个名为`Directory`的类和它的一个构造函数。

在`tfs()`函数内部，定义了一个名为`fs`的静态对象，它是`FileSystem`类的一个实例，并且返回了这个静态对象的引用。

在`Directory`类的构造函数内部，首先执行了一些初始化工作，然后通过调用`tfs()`函数获取到了`FileSystem`对象的引用，并通过该引用调用了`num_disks()`函数，将返回值存储在了一个名为`disks`的变量中。 

由于`tfs()`函数内部定义的`fs`对象是一个静态对象，因此它在程序运行期间只会被创建一次，并且在整个程序的生命周期内都存在。

每次调用`tfs()`函数时，都会返回同一个静态对象的引用。这种方式可以保证`FileSystem`类的实例只有一个，并且可以在全局范围内被访问。

在`Directory`类的构造函数内部，通过调用`tfs()`函数获取到了`FileSystem`对象的引用，并且调用了它的`num_disks()`函数，这种方式可以确保`Directory`类的实例可以访问到全局唯一的`FileSystem`对象，并且可以获取到该对象的属性和方法。 

总之，这段代码通过使用静态变量和函数，实现了一个全局唯一的`FileSystem`对象，并且可以在其他类的构造函数中使用该对象，从而避免了对象的多次创建和初始化，提高了程序的效率和可读性。同时，该代码还展示了C++中静态变量和静态函数的用法，可以作为学习C++语言的参考。

------

# 条款5：了解C++默认编写并调用哪些函数

条款5是指，在设计C++类时，必须要了解C++默认编写并调用哪些函数。具体来说，C++默认编写并调用的函数有以下几个：

1. 默认构造函数：如果用户没有显式地定义构造函数，则C++会自动生成一个默认构造函数，该函数不带任何参数，不执行任何操作。默认构造函数的作用是初始化对象的成员变量，如果没有定义，则成员变量的值是不确定的。
2. 默认析构函数：如果用户没有显式地定义析构函数，则C++会自动生成一个默认析构函数，该函数不带任何参数，用于释放对象所占用的资源。默认析构函数的作用是清理对象的状态，防止内存泄漏。
3. 默认拷贝构造函数：如果用户没有显式地定义拷贝构造函数，则C++会自动生成一个默认拷贝构造函数，该函数用于复制对象的成员变量。默认拷贝构造函数的作用是实现对象的复制功能，如果没有定义，则对象的复制会出现问题。
4. 默认拷贝赋值函数：如果用户没有显式地定义拷贝赋值函数，则C++会自动生成一个默认拷贝赋值函数，该函数用于将一个对象的值赋给另一个对象。默认拷贝赋值函数的作用是实现对象的赋值功能，如果没有定义，则对象的赋值会出现问题。
5. 默认移动构造函数和移动赋值函数：如果用户没有显式地定义移动构造函数和移动赋值函数，则C++会自动生成默认的移动构造函数和移动赋值函数，用于进行对象的移动操作。移动构造函数和移动赋值函数的作用是实现对象的移动操作，提高程序的效率。

通常情况下，如果代码中没有声明构造函数、拷贝构造函数、拷贝运算符、析构函数，编译器会在需要时创建他们，但这往往只能满足编译器的需求，很可能无法满足程序的需求。

实际的生成规则复杂一些，可以查阅cppreference。

```C++
class Empty{};
//上面的空类好比下面的类
class Empty{
public:
  Empty() { ... }
  Empty(const Empty& rhs) { ... }
  ~Empty() { ... }
  
  Empty& operator=(const Empty& rhs) { ... }
};
```

编译器生成的构造函数/析构函数是只是调用基类和非静态成员变量的构造函数/析构函数；生成的析构函数是非虚的，除非基类有虚析构函数。

 至于生成的拷贝构造函数和拷贝操作符只是单纯将每个非静态成员变量拷贝；有const成员或者引用成员时，以及基类拒绝拷贝操作符时，默认生成的拷贝操作符没有意义，必须自己定义。 

------

# 条款6：若不想使用编译器自动生成的函数，就该明确拒绝

条款6是指，在设计C++类时，如果不想使用编译器自动生成的函数，就应该明确拒绝。具体来说，如果类的某些函数不应该被自动生成（如拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数等），则应该通过显式声明和私有化的方式来明确拒绝它们的生成和使用。这种做法可以避免编译器自动生成的函数的使用带来的问题，同时也能够提高程序的可读性和可维护性。 具体的实现方式是，通过在类的定义中声明并私有化某些函数，来防止编译器自动生成它们。例如，可以通过将拷贝构造函数和拷贝赋值函数声明为私有函数来禁止对象的复制。代码示例如下：

```C++
class MyClass {
public:
    // 默认构造函数和析构函数是必须的，不能拒绝
    MyClass() = default;
    ~MyClass() = default;
    // 显式声明并私有化拷贝构造函数和拷贝赋值函数，明确拒绝它们的生成和使用
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;
    // 正常声明其他函数
    void foo();
    void bar();
};
```

在上面的代码中，我们通过`=delete`语句来显式地声明并私有化了拷贝构造函数和拷贝赋值函数，从而明确拒绝它们的生成和使用。这样一来，在其他地方调用这些函数时，编译器就会报错，从而提醒程序员需要注意。



很多时候，你并不希望某些类被拷贝，而仅仅不实现拷贝构造/拷贝运算符是不够的，因为编译器可能会自行生成。

为此，可以把拷贝构造/拷贝运算符声明为"=delete"，或者声明为private（后者较为过时）。

```C++
class Uncopyable{
public:
  Uncopyable() = delete;
  Uncopyable& operator=(const Uncopyable&) = delete;
};
```

事实上，对于析构函数中需要释放资源的类，为了防止内存问题，除非真的需要拷贝功能，否则最好都禁止拷贝。

可以让它们继承上面的类，即可禁止编译器生成拷贝操作：编译器试图为它们生成拷贝构造/拷贝运算符时会尝试调用基类Uncopyable的对应操作，而这会被拒绝。

```C++
class SomeClass: private Uncopyable{ ... };
```

------

# 条款7：为多态基类声明virtual析构函数

条款7是指，在C++中，如果一个类是多态基类，那么应该为它声明虚析构函数。具体来说，如果一个类将会被其他类所继承，并且这些派生类被用作多态基类，那么这个类的析构函数应该被声明为虚函数，以保证在派生类对象被销毁时正确地调用析构函数。因为在C++中，如果一个类的析构函数不是虚函数，那么在销毁一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄漏和程序错误。 为了解释这个问题，我们可以看下面这个例子：

```C++
class Base {
public:
    Base() {}
    ~Base() { cout << "Base destructor called" << endl; }
};
class Derived : public Base {
public:
    Derived() {}
    ~Derived() { cout << "Derived destructor called" << endl; }
};
int main() {
    Base* ptr = new Derived();
    delete ptr;  // 只会调用Base的析构函数，导致Derived的析构函数没有被调用，内存泄漏
    return 0;
}
```

在这个例子中，我们定义了一个基类`Base`和一个派生类`Derived`，并在`main`函数中创建了一个指向派生类对象的基类指针`ptr`。然后，我们调用`delete`语句释放`ptr`所指向的对象，期望同时调用`Base`和`Derived`的析构函数。但是，由于`Base`的析构函数不是虚函数，所以在销毁`ptr`时只调用了`Base`的析构函数，而没有调用`Derived`的析构函数，从而导致内存泄漏和程序错误。 为了解决这个问题，我们可以将`Base`的析构函数声明为虚函数，代码示例如下：

```C++
class Base {
public:
    Base() {}
    virtual ~Base() { cout << "Base destructor called" << endl; }  // 声明为虚函数
};
class Derived : public Base {
public:
    Derived() {}
    ~Derived() { cout << "Derived destructor called" << endl; }
};
int main() {
    Base* ptr = new Derived();
    delete ptr;  // 此时会依次调用Derived和Base的析构函数，避免内存泄漏
    return 0;
}
```

在这个例子中，我们将`Base`的析构函数声明为虚函数，这样在销毁`ptr`时就会依次调用`Derived`和`Base`的析构函数，从而正确地释放对象的内存。

------

C++中多态性质体现于虚函数：基类指针或引用调用虚函数时会检查指向的对象是基类还是派生类，再调用对应的函数。

> 在C++中，实现多态性的核心机制是虚函数。虚函数是在基类中声明的，可以在派生类中重写。在使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后调用对应的函数。**具体实现可以分为两个步骤：虚函数表和动态绑定。**
>
> 1. 虚函数表：每个类都有一个虚函数表，也叫虚表(virtual table)，用来存储该类的虚函数地址。
>
> 	虚函数表是在编译阶段生成的，每个类都有自己的虚函数表，其中存储着该类的虚函数地址。
>
> 	虚函数表通常被作为类的第一个成员，在对象的内存布局中，虚表指针被放在对象的最前面，以便访问虚函数表中的地址。 
>
> 	对于包含虚函数的类，编译器会在编译阶段自动生成一个虚函数表，其中存储了该类的虚函数地址。
>
> 	虚函数表是一个数组，每个元素对应一个虚函数的地址。在类的构造函数中，会将该类的虚表指针指向该类的虚函数表。
>
> 	在调用虚函数时，编译器会通过虚表指针找到该类的虚函数表，并根据函数在虚函数表中的位置调用相应的函数。
>
> 2. 动态绑定：动态绑定是指在运行时确定函数的调用地址的过程。
>
> 	**当使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后根据对象的实际类型来确定调用哪个函数。这个过程被称为动态绑定或后期绑定。** 
>
> 	**动态绑定的实现需要依赖虚表指针。**当使用基类指针或引用调用虚函数时，编译器会根据指针或引用的静态类型确定该类的虚表指针，然后根据虚表指针找到该类的虚函数表，再根据虚函数在虚函数表中的位置找到对应的函数地址。然后在运行时根据对象的实际类型调用相应的函数。 
>
> 	**总的来说，C++中多态的实现是基于虚函数表和动态绑定的。**虚函数表存储了类的虚函数地址，而动态绑定则根据对象的实际类型来确定调用哪个函数。虽然虚函数表和动态绑定会增加程序的运行时开销，但是它们是实现多态的核心机制，使得程序能够更加灵活和可扩展。

当这样的一个指向派生类的基类指针析构时，如果析构函数不是虚函数，则直接调用基类的析构函数，那么派生类获取的资源未释放，则会造成内存泄漏。

而当析构函数是虚函数时则先调用对应的派生类析构函数，再调用基类析构函数，资源全部释放。

不过这种操作只有在基类是多态用途时才需要注意，也有很多类不是为了多态的用途，例如STL容器和上文的Uncopyable。

------

# 条款8：别让异常逃离析构函数

C++中抛出异常时会逐步展开其函数调用栈，清空局部资源，直到异常被catch。

如果析构函数可以抛出异常，那么清空局部资源时局部对象的析构函数再次异常时同时存在两个异常，C++无法处理，可能会过早结束或出现不明确行为。因此，析构函数绝对不要抛出异常，应通过try-catch捕获任何异常。

有时，客户需要处理某些异常，那么类应该提供一个普通成员函数执行相关操作，供用户调用并处理异常。

例如数据库连接这样的类中，假设用户需要处理关闭连接时的异常，同时析构函数不能抛出异常，可以这样：

```c++
class DBConn{
public:
  void close(){
    db.close();
    closed = true;
  }
  ~DBConn()
  {
    if(!closed)
    {
        try{
          db.close();
        }catch(...){
        //记录相关信息
        }
    }
  }
private:
  DBConnection db;
  bool closed;
};
```

------

# 条款9：绝不在构造和析构过程中调用virtual函数

C++的构造过程是先构造基类再构造子类、先初始化再进入构造函数体；析构过程相反。

对于派生类的构造函数而言，进入其中时基类部分已构造完而派生类部分未构造完，对象类型是基类，故而此时调用虚函数，实际上使用的是基类的虚函数。

析构函数同理。进入析构函数后派生类部分呈未定义值，对象类型是基类，调用的是基类的虚函数。

总而言之，在构造函数与析构函数中虚函数的行为有特殊变化；为了避免出错，不要在其过程中使用虚函数。如果确实需要在构造函数或析构函数中调用虚函数，可以使用非虚函数或纯虚函数代替虚函数，或者在构造函数或析构函数中显式调用基类中的函数。

------

# 条款10：令operator=返回一个reference to *this

> 条款10提醒我们在实现自定义的赋值运算符(operator=)时，应该将其返回类型定义为引用(reference)类型，并返回一个指向当前对象的指针(*this)，以便实现连续赋值和链式调用的功能。这种做法被称为“返回一个reference to *this”。

C++中通常支持连锁赋值，采用右结合律：

```C++
int a,b,c;
a = b = c = 15;
// a = (b = (c = 15));
```

> 具体来说，如果我们将赋值运算符的返回类型定义为值(value)类型，那么在进行多次赋值时，每次都会创建一个新的临时对象，这会导致不必要的内存分配和拷贝，降低程序的执行效率。而如果将赋值运算符的返回类型定义为引用类型，可以避免创建临时对象，提高程序的执行效率。
>
> 同时，返回一个指向当前对象的指针(*this)也可以实现链式调用的功能。在链式调用中，每个函数调用的返回值都是当前对象的引用，这样就可以一直链式调用下去，从而使代码更加简洁和易读。

为了支持这个常规，拷贝运算符需要返回一个引用。这一条款并不强制，但约定俗成。

```C++
class Widget{
public:
  Widget& operator=(const Widget& rhs){
    ...
    return *this;
  }
};
```

------

# 条款11：在operator=中处理“自我赋值”

> 条款11提醒我们在实现自定义的赋值运算符(operator=)时，需要特别注意处理“自我赋值”(self-assignment)的情况，即将一个对象赋值给它自身。 如果没有正确处理自我赋值的情况，可能会导致对象的状态出现错误，甚至导致程序崩溃。因此，在实现赋值运算符时，必须处理自我赋值的情况，以保证程序的正确性和稳定性。

处理自我赋值的方法通常有两种：

1. 引入临时对象。在处理自我赋值时，可以先创建一个临时对象，将原对象的状态拷贝到临时对象中，然后再将临时对象的状态赋值给原对象。这样可以避免在拷贝原对象的状态时被自我赋值所影响。需要注意的是，在创建临时对象时，应该使用拷贝构造函数而不是赋值运算符，以避免在处理自我赋值时再次调用赋值运算符。

2. 检查自我赋值。在处理赋值运算符时，可以先检查赋值运算符的左右两边是否是同一个对象，如果是，则直接返回该对象，不进行任何操作。这样可以避免在处理自我赋值时出现错误。 需要注意的是，处理自我赋值时，不仅要考虑到对象的成员变量，还需要考虑到对象可能维护的资源，如内存、文件句柄等。如果对象维护了资源，需要在处理自我赋值时特别注意释放和重新分配资源的顺序，以避免出现资源泄漏或访问非法内存等问题。 

	因此，在实现自定义的赋值运算符时，需要特别注意处理自我赋值的情况。处理自我赋值的方法可以是引入临时对象或检查自我赋值，需要根据具体情况选择合适的方法。同时，需要注意处理对象维护的资源，以保证程序的正确性和稳定性。

考虑这样一个类，其中管理了一个堆对象

```C++
class Widget{
  ...
private:
  Bitmap* pb; //一个堆对象
};
```

总有些时候，会出现实质上“a=a”这种自我赋值的情况。那么这样简单的拷贝运算符就会出错，先释放了自身的pb，又使用了pb：

```C++
Widget& Widget::operator=(const Widget& rhs){
  delete pb;
  pb = new Bitmap(*rhs.pb);
  return *this;
}
```

传统做法是函数开头添加一个测试：

```C++
if(this == &rhs) return *this;
```

这种做法具备“自我赋值安全性”，但不具备“异常安全性”：例如当new Bitmap异常时，pb指向被删除的内存。

常用的方法有两种，兼顾了“自我赋值安全性”与“异常安全性”：

```C++
//第一种
Widget& Widget::operator=(const Widget& rhs){
  Bitmap* pb_original = pb;
  pb = new Bitmap(*rhs.pb);
  delete pb_original;
  return *this;
}
//第二种
void Widget::swap(Widget& rhs){
  ...
};
Widget& Widget::operator=(const Widget& rhs){
  Widget temp(rhs);
  swap(temp);
  return *this;
}
```

------

# 条款12：复制对象时勿忘其每一个成分

当自己实现拷贝构造/拷贝运算符时，编译器不会警告你遗漏了某些成员变量。因此，必须仔细地复制所有派生类成员，并调用基类的拷贝操作来复制基类成员。

```C++
Derived::Derived(const Derived& rhs)
  :Base(rhs),some_member(rhs.some_member){}

Derived& Derived::operator=(const Derived& rhs){
  Base::operator=(rhs);
  some_member = rhs.some_member;
  return *this;
}
```

拷贝构造和拷贝运算符中很可能有相当多重复的操作，但因为两个函数性质完全不同，因此不能用其中一个调用另一个来减少冗余。

可以把共同功能放在第三个函数中，并由两个拷贝操作共同调用。

# 条款13：以对象管理资源



# 条款14：在资源管理类中小心copying行为



# 条款15：在资源管理类中提供对原始资源的访问



# 条款16：成对使用new和delete时要采用相同形式



# 条款17：以独立语句将newed对象置入智能指针



# 条款18：让接口容易被正确使用，不易被误用



# 条款19：设计class犹如设计type



# 条款20：宁以pass-by-reference-to-const替换pass-by-value



# 条款21：必须返回对象时，别妄想返回其reference



# 条款22：将成员变量声明为private



# 条款23：宁以non-member、non-friend替换member函数



# 条款24：若所有参数皆需类型转换，请为此采用non-member函数



# 条款25：考虑写出一个不抛出异常的swap函数



# 条款26：尽可能延后变量定义式的出现时间



# 条款27：尽量少做转型动作







# 条款28：避免返回handles指向对象内部成分

在C++中，handles是指一个指向对象的指针或引用，用于访问该对象的成员函数或成员变量。

而条款28所说的“返回handles指向对象内部成分”，是指返回指向该对象的私有成员或受保护成员的指针或引用。 

这样做的问题在于，如果对该成员进行修改或者删除操作，可能会破坏该对象的不变量（invariant）或者类的封装性，导致程序出现不可预测的结果。

另外，如果返回的指针或引用是指向临时对象或已经被释放的对象，则会导致指针悬挂（dangling pointer）或引用无效的问题。 

为了避免这种问题，建议使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。

如果必须返回指针或引用，可以考虑使用智能指针（如`std::shared_ptr`或`std::unique_ptr`）来确保对象的生命周期，或者返回const指针或引用，防止被修改。

假设有一个类`Person`，其中有一个私有变量`age`表示年龄，如下所示：

```C++
class Person {
public:
    void SetAge(int age) { this->age = age; }  // 设置年龄
    int GetAge() const { return age; }  // 获取年龄
private:
    int age;
};
```

如果在该类中返回对`age`的引用或指针，就会存在返回handles指向对象内部成分的问题。例如：

```C++
const int& GetAgeRef() const { return age; }  // 返回对age的引用
const int* GetAgePtr() const { return &age; }  // 返回指向age的指针
```

在这种情况下，如果返回的引用或指针被用于修改或者删除`age`，将会破坏`Person`类的封装性，导致程序出现不可预测的结果。 为了解决这个问题，可以使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。例如：

```c++
class Person {
public:
    void SetAge(int age) { this->age = age; }  // 设置年龄
    int GetAge() const { return age; }  // 获取年龄
    void SetAgeViaFunction(int age) { SetAge(age); }  // 通过公有成员函数设置年龄
private:
    int age;
};
```

在这个例子中，我们新增了一个公有成员函数`SetAgeViaFunction`，用于通过公有成员函数`SetAge`来设置年龄。这样，外部代码就不能直接访问`age`，而是必须通过`SetAgeViaFunction`来访问`age`，从而保证了`Person`类的封装性。



# 条款29：为“异常安全”而努力是值得的

> “异常安全”是指程序在面对异常时，能够保持正确性、资源不泄漏、不破坏数据结构等性质。
>
> 在C++中，异常安全是非常重要的，因为C++支持异常机制，如果程序无法正确处理异常，可能会导致资源泄漏、内存泄漏、数据结构损坏等问题，从而影响程序的正确性和稳定性。

请记住：

1. 异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。
2. “强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证“并非对所有函数都可实现或具备现实意义。
3. 函数提供的”异常安全保证“通常最高只等于其所调用的各个函数的”异常安全保证“中的最弱者。

因此，为了确保程序的异常安全性，我们需要在编写代码时，考虑并努力实现异常安全。具体来说，我们需要注意以下几点：

1. 确保不会让异常逃逸：在函数中抛出异常后，应该确保异常被正确地处理掉，而不是让它逃逸到函数外部，导致资源泄漏或数据结构损坏。为了避免异常逃逸，可以使用RAII技术，通过在对象构造函数中获取资源，在对象析构函数中释放资源，来保证资源的正确获取和释放。

2. 考虑异常安全的级别：异常安全性有三个级别，分别是基本保证、弱异常安全和强异常安全。在编写代码时，应该根据情况选择最佳的异常安全级别。

	基本保证是指：如果函数出现异常，程序状态不会受到破坏，但是可能会发生资源泄漏。

	弱异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，但是可能会出现不一致的状态。

	强异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，而且程序状态和资源都会回到调用函数前的状态。

3. 使用异常处理机制：在编写代码时，应该使用异常处理机制来处理异常。通过抛出异常并捕获异常，可以避免程序崩溃，并将异常抛出给调用者进行处理。在抛出异常时，应该提供一个清晰的异常信息，方便调用者进行处理。 

# 条款30：透彻了解inlining的里里外外

条款30中的"inlining"是指C++中的内联函数，它是一种编译器的优化技术，可以将函数调用处直接替换为函数体，从而减少函数调用的开销，提高程序的性能。但是，内联函数也有一些限制和缺点，因此，在使用内联函数时，需要透彻了解其里里外外，以便能够正确地使用和优化内联函数。 

具体来说，理解"inlining"的里里外外需要注意以下几点：

1. 内联函数的适用范围：内联函数适用于函数体比较小、被频繁调用的函数。如果函数体比较大，内联函数可能会导致代码膨胀，从而影响程序的性能。因此，在使用内联函数时，需要根据实际情况进行选择。
2. 内联函数的定义：内联函数通常需要在头文件中进行定义，以便编译器能够在编译时进行函数替换。**在定义内联函数时，需要注意函数体不能包含循环、递归等语句，否则会导致编译器无法进行内联**。
3. 内联函数的声明：内联函数的声明通常也需要在头文件中进行，以便其他文件能够调用内联函数。**在声明内联函数时，需要使用inline关键字，**以便告诉编译器该函数需要进行内联。
4. 内联函数的优化：在使用内联函数时，需要注意优化内联函数的代码，以提高程序的性能。**可以使用一些技巧，如避免多余的函数调用、避免局部变量过多、使用常量表达式等**。
5. 内联函数的限制：内联函数也有一些限制，例如不能取地址、不能有静态变量等。在使用内联函数时，需要注意这些限制，以便正确地使用内联函数。

请记住：

1. 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
2. 不要只因为function templates 出现在头文件，就将它们声明为inline

> ==**如何理解“不要只因为function templates 出现在头文件，就将它们声明为inline”这句话？**==

在C++中，函数模板（function templates）是一种通用的函数定义方式，它可以用来定义多个具有相同功能但类型不同的函数。**由于函数模板通常需要在头文件中进行定义，因此很容易将它们声明为内联函数（inline）以提高程序的性能。**但是，**在使用函数模板时，不要只因为它们出现在头文件中，就将它们声明为内联函数**，而应该根据实际情况进行选择。 具体来说，不要将所有函数模板都声明为内联函数的原因有以下几点：

1. **函数模板的大小不确定**：由于函数模板可以用于定义多个函数，因此其大小在编译时是不确定的。如果将所有函数模板都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。
2. **内联函数的适用范围有限**：内联函数适用于函数体比较小、被频繁调用的函数。对于函数模板来说，其具体调用情况是不确定的，因此并不是所有函数模板都适合声明为内联函数。
3. 其他优化方式：除了将函数模板声明为内联函数之外，还有其他一些优化方式，如使用编译器的优化选项、避免多余的函数调用等。在使用函数模板时，应该根据实际情况选择最合适的优化方式。 

因此，不要只因为函数模板出现在头文件中，就将它们声明为内联函数。应该根据实际情况进行选择，综合考虑函数模板的大小、调用情况、优化方式等因素，以便选取最合适的优化方案。

> **==如何理解“将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。”这句话？==**

这句话指出了在使用内联函数时应该将大多数内联函数限制在小型、被频繁调用的函数中，以便最大化程序的速度提升机会，并最小化潜在的代码膨胀问题，同时也方便了日后的调试过程和二进制升级。 具体来说，这句话的含义可以从以下几个方面进行解释：

1. **内联函数的适用范围**：内联函数适用于函数体比较小、被频繁调用的函数。将大多数内联函数限制在这样的函数中，可以最大化程序的速度提升机会，因为内联函数可以减少函数调用的开销。
2. **调试和升级的问题**：将内联函数限制在小型、被频繁调用的函数中，可以使调试过程更加容易，因为这些函数的代码比较简单，容易定位和排查问题。同时，也方便了二进制升级，因为这些函数的代码不会对其他部分的代码产生过多的影响。
3. **代码膨胀问题**：内联函数会将函数体直接嵌入到调用处，从而增加代码的长度。如果将所有函数都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。将大多数内联函数限制在小型、被频繁调用的函数中，可以最小化潜在的代码膨胀问题，并提高程序的性能。 

综上所述，将大多数内联函数限制在小型、被频繁调用的函数中，可以最大化程序的速度提升机会，最小化潜在的代码膨胀问题，并方便了日后的调试过程和二进制升级。



# 条款31：将文件间的编译依存关系降至最低

条款31指出了在软件开发中，应该尽可能地将文件间的编译依存关系降至最低，以便实现更好的模块化和可重用性。具体来说，可以从以下几个方面来理解这个条款：

1. 编译依存关系：文件间的编译依存关系指的是一个源文件（或头文件）在编译时所依赖的其他源文件（或头文件）。如果一个源文件依赖于另外的源文件，那么在编译时就需要将这些源文件一起编译，从而增加了编译时间和编译的复杂性。

2. 最小化编译依存关系的好处：将文件间的编译依存关系降至最低，可以实现更好的模块化和可重用性。

	模块化指的是将软件系统分解为多个独立的模块，每个模块都具有清晰的接口和功能；

	可重用性指的是可以将一个模块在不同的系统中重复使用。

	最小化编译依存关系可以使得每个模块都具有清晰的接口和功能，从而提高了模块化和可重用性。

3. 实现最小化编译依存关系的方法：实现最小化编译依存关系的方法有很多，比如使用前置声明（forward declaration）、将接口和实现分离、使用接口类（interface class）等。

	前置声明可以减少头文件之间的相互依赖；将接口和实现分离可以使得模块之间的依赖更加清晰；

	使用接口类可以将模块之间的依赖限制在接口上，从而提高了模块化和可重用性。

以下是对该条款的理解和一些实践建议：

1. **减少头文件的依赖**：尽量减少头文件之间的相互包含，只包含必要的头文件。这样可以降低编译依存关系，避免引入不必要的依赖关系。

2. **使用前向声明（Forward Declaration）**：如果在头文件中只需要使用某个类的指针或引用而不需要知道其具体实现细节，可以使用前向声明来代替包含整个头文件。这样可以减少头文件的依赖关系。

3. **使用接口类（Interface Class）**：将公共接口定义在一个独立的接口类中，然后在其他文件中使用该接口类而不是具体的实现类。这样可以降低对具体实现类的依赖，提高代码的可扩展性和可替换性。

4. **使用编译器前置声明（Compiler Firewall）**：在某个实现文件中使用前向声明和指针/引用，然后在该文件的头文件中包含所需的具体实现。这样可以将依赖关系局限在该实现文件内部，减少对其他文件的影响。

5. **使用纯虚函数（Pure Virtual Functions）**：如果某个类在其他文件中只需要通过指针或引用进行操作，可以将该类设计为纯虚函数的基类，然后使用基类的指针或引用来操作具体的子类。这样可以降低对具体子类的依赖，提高代码的灵活性和可扩展性。

总的来说，条款31的目标是通过降低文件间的编译依存关系，减少代码间的耦合性，从而提高代码的可维护性和可扩展性。通过合理的头文件设计、前向声明、接口类和编译器前置声明等技术手段，可以将依赖关系限制在合适的范围内，使代码更加模块化、可重用和易于维护。



# 条款32：确定你的pubilc继承塑模出is-a关系

条款32强调使用公共继承（public inheritance）时，需要确保所使用的继承能够正确地塑模出"is-a"关系。这意味着子类对象应该能够被视为基类对象的一种特殊类型。

下面是对该条款的理解和一些建议：

1. **理解"is-a"关系**：在公共继承中，子类继承了基类的接口和行为，并且可以通过基类指针或引用进行操作。这意味着子类对象应该能够被视为基类对象的一种特殊类型，即子类对象应该可以替代基类对象使用，并且在行为和使用方式上与基类对象相似。

2. **遵循Liskov替换原则**：Liskov替换原则指出，子类对象应该能够替换基类对象并且不会破坏程序的正确性。也就是说，在使用基类对象的地方，如果用子类对象替换后程序仍然正确运行，则说明公共继承的"is-a"关系得到了正确地塑模。

3. **注意虚函数的重写**：在公共继承中，子类可以重写基类的虚函数以改变其行为。但是，需要确保重写的虚函数在行为上与基类的虚函数是一致的，并且满足Liskov替换原则。这样，在使用基类指针或引用操作子类对象时，能够获得预期的行为。

4. **避免破坏类的不变式**：在子类中进行继承时，需要避免破坏基类所定义的类不变式（class invariants）。类不变式是描述类对象状态约束的规则，继承关系应该遵循这些规则，以确保对象的一致性和正确性。

5. **慎重使用非虚继承**：非虚继承（non-virtual inheritance）==用于处理多继承时的菱形继承问题，但它不适用于"is-a"关系的建立。==非虚继承更适用于表示某种组合关系（has-a）而不是"is-a"关系，因此在公共继承中应慎重使用非虚继承。

总结来说，条款32的目标是确保使用公共继承能够正确地塑模出"is-a"关系，即子类对象能够替代基类对象并且在行为和使用方式上与基类对象相似。遵循Liskov替换原则、注意虚函数的重写、避免破坏类的不变式等原则，可以帮助我们正确使用公共继承并避免问题。

==**请记住：**==

==**“public 继承”意味 is-a 。适用于base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个derived class 对象也都是一个base class 对象。**==



# 条款33：避免遮掩继承而来的名称

**条款33强调避免在派生类中遮掩（hide）继承而来的名称。当派生类中定义了与基类相同名称的成员函数或成员变量时，这些新定义的成员会遮掩基类中相同名称的成员，使其在派生类中不可见。**

以下是对该条款的理解和一些建议：

1. **名称遮掩的问题**：当派生类中定义了与基类相同名称的成员时，派生类的成员会隐藏（hide）基类的成员。这可能导致代码中的名称冲突和不一致，使得基类的成员在派生类中不可见。

2. **使用作用域解析运算符**：如果在派生类中需要访问基类中被遮掩的成员，可以使用作用域解析运算符（::）来显式指定所属的作用域。例如，可以使用`Base::foo()`来调用基类中的`foo()`函数。

3. **重载与隐藏的区别**：派生类中的函数重载（overload）是指在派生类中定义了与基类同名但参数列表不同的成员函数。**重载不会导致基类的同名函数被遮掩，而是构成了函数重载集。**只有当函数名和参数列表完全相同时，才会发生名称遮掩。

4. **使用using声明**：如果希望在派生类中保留基类中的同名成员的可见性，可以使用`using`声明来引入基类的名称。使用`using Base::foo;`可以使基类中的`foo`在派生类中可见，并且可以直接调用。

5. **使用转交函数(function forwarding)：**

	在派生类中定义一个与基类同名的函数，这个函数将被外部调用。

	在派生类的同名函数中，调用基类的同名函数，可以使用作用域解析运算符（::）来显式指定基类的作用域。

	以下是一个示例代码：

	```C++
	class Base {
	public:
	    void foo() {
	        // 基类的函数实现
	    }
	};
	
	class Derived : public Base {
	public:
	    void foo() {
	        Base::foo();  // 转交函数，调用基类的同名函数
	        // 派生类的其他操作
	    }
	};
	```

	在上述示例中，派生类Derived中的foo函数转交了基类Base中的foo函数的调用，即在派生类的foo函数中先调用基类的foo函数，然后再执行派生类的其他操作。

总结来说，条款33的目标是避免在派生类中遮掩继承而来的名称，以避免名称冲突和不一致性。通过使用作用域解析运算符、重载和using声明、转交函数等技术手段，可以解决名称遮掩的问题，确保基类的成员在派生类中仍然可见并且可用。这样可以提高代码的可读性和可维护性。

==**请记住：**==

==**derived classes 内的名称会遮掩base classes 内的名称。在public 继承下从来没有人希望如此。**==

==**为了让被遮掩的名称再见天日，可使用using 声明式或转交函数（forwarding functions）。**==



# 条款34：区分接口继承和和实现继承

这个条款的核心思想是，继承应该被用于两种不同的目的：接口继承和实现继承。这两种继承方式有着不同的目标和应用场景。

1. 接口继承（Interface Inheritance）：
	- 接口继承指的是从基类中继承纯虚函数，即只有函数签名而没有实际实现的函数。
	- 接口继承的目的是创建一个抽象的基类，用于定义一组规范或接口，而不关注具体的实现细节。
	- 派生类必须实现基类中的纯虚函数，以便成为一个具体的类。
	- 通过接口继承，可以实现多态，允许将派生类对象赋值给基类指针或引用，并在运行时调用正确的实现。

2. 实现继承（Implementation Inheritance）：
	- 实现继承指的是从基类继承具有实际实现的函数。
	- 实现继承的目的是通过基类的共同实现来重用代码。
	- 实现继承可以将基类的功能直接继承到派生类中，但它会将基类和派生类紧密地耦合在一起，可能导致较高的继承层次结构复杂性。
	- 使用实现继承时，派生类在某种程度上是基类的"特例"，它拥有基类的所有功能，并可能添加自己的特定实现。

==**请记住：**==

- ==**接口继承和实现继承不同。在public 继承之下，derived classes 总是继承base classes 的接口。**==
- ==**声明一个pure virtual 函数的目的是为了让derived classes 只继承函数接口。**==
- ==**声明简朴的（非纯）impure virtual 函数的目的，是让derived classes 继承该函数的接口和缺省实现。**==
- ==**声明non-virtual 函数的目的是为了令derived classes 继承函数的接口及一份强制性实现，non-virtual 函数代表的意义是不变性凌驾特异性，所以它绝不该在derived class 中被重新定义。**==

# 条款35：考虑virtual 函数以外的其他选择

这个条款的目的是引导开发者在使用虚函数之前，先考虑一些替代方案。

虚函数允许在基类中声明函数，并允许派生类重写该函数以实现特定行为。然而，使用虚函数可能会引入一些开销，如虚表指针（vptr）和虚表（vtable），以及运行时的动态绑定。在某些情况下，这些开销可能是不必要的或不适用的。

在条款35中，Meyers提供了一些替代虚函数的选择：

1. 将函数声明为非虚函数：

	- 如果确定某个函数在派生类中不需要被重写，可以将其声明为非虚函数。
	- 这样做可以避免虚函数带来的运行时开销，并且使编译器能够进行更多的优化。

2. 使用非虚函数接口（non-virtual interface，NVI）手法来实现模板方法模式（Template Method Pattern）：

	> 这一基本设计，也就是“令客户通过public non-virtual 成员函数间接调用 private virtual 函数”，称为 non-virtual interface (NVI)手法。它是所谓Template Method 设计模式（与C++ templates 并无关联）的一个独特变现形式。侯捷把这个non-virtual 函数称为virtual 函数的外覆器（wrapper）。

	- 这种方法利用了C++的多态性和访问控制机制，允许派生类在模板方法中实现自己的行为。

	- 模板方法模式是一种设计模式，其中基类定义了一个模板方法（template method），该方法定义了算法的骨架，但允许派生类实现其中的一些步骤。

	- 模板方法模式通过将可变的部分交给派生类来实现，从而提供了一种替代虚函数的方法。

	- 下面是通过非虚函数接口手法实现模板方法模式的步骤：

		1. 定义基类（抽象类）：首先，定义一个基类，它包含一个公共的非虚函数接口方法，用于定义模板方法的结构。该方法通常称为模板方法。

		```cpp
		class Base {
		public:
		    void templateMethod(/* 参数列表 */) {
		        // 通用的处理代码...
		
		        // 调用派生类实现的虚函数
		        doSomething(/* 参数列表 */);
		
		        // 通用的处理代码...
		    }
		
		private:
		    virtual void doSomething(/* 参数列表 */) = 0; // 纯虚函数，由派生类实现
		};
		```

		2. 派生类实现：派生类继承自基类，并实现基类中的纯虚函数，提供自己的行为。

		```cpp
		class Derived : public Base {
		private:
		    void doSomething(/* 参数列表 */) override {
		        // 派生类的特定实现...
		    }
		};
		
		// 可以定义更多的派生类，每个派生类提供自己的行为...
		```

		3. 使用模板方法：创建基类或派生类的实例，并调用模板方法。

		```cpp
		Base* obj = new Derived(); // 使用基类指针指向派生类对象
		
		obj->templateMethod(/* 参数列表 */); // 调用模板方法
		```

		通过使用非虚函数接口（NVI）手法，基类中的模板方法可以定义算法的结构，同时调用派生类实现的非虚函数。这样，派生类可以在模板方法中实现自己的行为，从而实现了模板方法模式。非虚函数接口手法通过将派生类的实现封装在非虚函数中，将多态性限制在基类的内部，并提供更好的控制和灵活性。

		需要注意的是，NVI手法并不是C++中的特定功能或语言特性，而是一种设计模式实践。它利用了C++中的多态性和访问控制机制，将模板方法模式应用于具体的类设计中。

3. 使用函数对象（Function Objects）：

	- 函数对象是可调用对象，可以像函数一样使用。它们可以通过重载`operator()`来实现多态行为。
	- 使用函数对象可以避免虚函数的开销，并提供更大的灵活性和可扩展性。

4. 藉由Function Pointers 实现策略模式（Strategy Pattern）：

	- 策略模式是一种设计模式，其中算法被封装在不同的策略类中，并通过基类指针或引用在运行时选择合适的策略。

	- 使用策略模式可以避免虚函数的开销，并提供更大的灵活性和可维护性。

	- 下面是通过函数指针实现策略模式的步骤：

		1. 定义函数指针类型：首先，定义一个函数指针类型，它与策略函数的签名相匹配。

		```cpp
		using StrategyFunctionPtr = void (*)(/* 参数列表 */);
		```

		2. 定义策略函数：然后，实现具体的策略函数，这些函数与策略函数指针的签名匹配。

		```cpp
		void ConcreteStrategy1(/* 参数列表 */) {
		    // 具体策略1的实现...
		}
		
		void ConcreteStrategy2(/* 参数列表 */) {
		    // 具体策略2的实现...
		}
		
		// 定义更多的具体策略函数...
		```

		3. 使用函数指针存储策略：声明一个函数指针变量，并根据需要，将不同的策略函数的地址赋值给它。

		```cpp
		StrategyFunctionPtr strategy; // 声明函数指针变量
		
		// 选择具体策略1
		strategy = &ConcreteStrategy1;
		
		// 选择具体策略2
		strategy = &ConcreteStrategy2;
		```

		4. 执行策略：通过调用函数指针，执行选定的策略函数。

		```cpp
		strategy(/* 参数列表 */); // 执行选定的策略函数（具体策略1或具体策略2）
		```

		使用函数指针可以实现策略模式的动态选择和执行。通过将不同的策略函数的地址赋值给函数指针，可以在运行时根据需要选择适当的策略。这种方法提供了一种简单而有效的策略模式实现方式，但需要注意函数指针的签名匹配。

		需要注意的是，使用函数指针实现策略模式可能存在一些限制，例如无法存储具有不同签名的策略函数，以及难以处理需要状态或上下文的策略。在这种情况下，使用函数对象（如前面提到的`std::function`）可能更加灵活和方便。

5. 藉由tr1::function完成Strategy模式

	提及的`tr1::function`是指C++ Technical Report 1（TR1）中引入的函数对象类型。在当前的C++标准（C++11及以后），`std::function`是相应的功能。

	理解通过`std::function`（或`tr1::function`）来完成策略模式，可以采用以下步骤：

	1. 定义策略接口：首先，定义一个策略接口（或基类），其中包含定义所有策略对象都必须实现的纯虚函数。

	```cpp
	class StrategyInterface {
	public:
	    virtual void execute() = 0;
	    // 其他纯虚函数或接口方法...
	};
	```

	2. 实现具体策略：接下来，为每个具体的策略实现一个类，这些类派生自策略接口，并提供自己的实现。

	```cpp
	class ConcreteStrategy1 : public StrategyInterface {
	public:
	    void execute() override {
	        // 具体策略1的实现...
	    }
	};
	
	class ConcreteStrategy2 : public StrategyInterface {
	public:
	    void execute() override {
	        // 具体策略2的实现...
	    }
	};
	
	// 可以定义更多的具体策略类...
	```

	3. 使用`std::function`存储策略：使用`std::function`来存储不同策略对象的可调用实例。这样可以实现运行时的策略选择。

	```cpp
	#include <functional>
	
	std::function<void()> strategy; // 使用std::function存储策略对象
	
	// 选择具体策略1
	strategy = []() {
	    ConcreteStrategy1 strategy1;
	    strategy1.execute();
	};
	
	// 选择具体策略2
	strategy = []() {
	    ConcreteStrategy2 strategy2;
	    strategy2.execute();
	};
	```

	4. 执行策略：通过调用`std::function`中存储的策略对象，执行相应的策略。

	```cpp
	strategy(); // 执行选定的策略（具体策略1或具体策略2）
	```

	使用`std::function`（或`tr1::function`）可以方便地存储不同策略对象，并在运行时选择和执行特定的策略。通过使用函数对象类型，可以实现策略模式的灵活性和可扩展性，而无需修改现有的策略接口和具体策略类。

	请注意，自C++11起，使用`std::function`更为常见和推荐，而非`tr1::function`。

==**请记住：**==

- ==**virtual 函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method 设计模式。**==
- ==**将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。**==

- ==**tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。**==

# 条款36：绝不重新定义继承而来的non-virtual函数

这个原则强调了在继承关系中对于非虚函数的使用和重写的限制。

理解条款36的关键点如下：

1. 非虚函数与虚函数的区别：非虚函数是在基类中定义的普通成员函数，而虚函数是在基类中定义且使用`virtual`关键字声明的函数。虚函数支持运行时的动态绑定，而非虚函数则使用静态绑定。

2. 非虚函数的继承行为：当派生类继承一个非虚函数时，基类中的非虚函数会在派生类中保持相同的行为，不会被派生类重新定义或覆盖。

3. 危险的重新定义：重新定义（override）一个继承而来的非虚函数是危险的行为。这是因为在继承链中，通过基类指针或引用调用非虚函数时，实际调用的是静态类型（基类）的函数，而不是动态类型（派生类）的函数。这可能导致意外的行为和不一致的结果。

4. 虚函数的重写：与非虚函数不同，派生类可以通过在派生类中重新定义（override）虚函数来改变其行为。这样，当通过基类指针或引用调用虚函数时，会根据实际的动态类型调用正确的函数。

总而言之，条款36建议避免重新定义继承而来的非虚函数，以防止意外的行为和不一致性。如果需要改变继承而来的函数的行为，应该将该函数声明为虚函数，并在派生类中进行重写。这样可以确保正确的多态行为，并遵循Liskov替换原则（Liskov Substitution Principle）的规定。

==**请记住：**==

- ==**绝对不要重新定义继承而来的non-virtual函数。**==

> Liskov替换原则是什么？
>
> Liskov替换原则（Liskov Substitution Principle）是面向对象设计的一个重要原则，由计算机科学家Barbara Liskov提出。该原则指导着正确和合理地使用继承和多态性，以确保软件系统的可靠性和可扩展性。
>
> Liskov替换原则可以简要描述为：
>
> "如果S是T的子类型，那么在不破坏程序的正确性的前提下，任何程序中的T类型的对象都可以被替换为S类型的对象。"
>
> 换句话说，子类型（派生类）应该能够替换其基类型（基类）在任何程序中的使用，而不会引入错误或破坏程序的行为。这个原则的目标是保持代码的一致性、可维护性和可扩展性。
>
> 遵循Liskov替换原则的关键要点如下：
>
> 1. 子类型的行为：子类型（派生类）应该完全符合其基类型（基类）的约定、协议和合约。即，子类型应该实现基类型的所有接口，并保持相同的行为和预期结果。
>
> 2. 不破坏基类型的不变量：子类型的操作和行为不应破坏基类型的不变量、约束和规范。即，子类型不应该放宽基类型的前置条件、加强后置条件或改变基类型的约束。
>
> 3. 不破坏客户端代码：子类型的使用不应该强制客户端代码进行特定的类型检查或假设。即，客户端代码应该能够以基类型的方式使用子类型对象，而不需要做任何额外的处理。
>
> 遵循Liskov替换原则有助于构建稳健和可靠的软件系统。它鼓励设计合理的继承关系，正确使用多态性，并确保代码的一致性和可扩展性。同时，它也提供了一种指导原则，帮助开发者评估和调整继承关系中的设计选择和决策。

# 条款37：绝不重新定义继承而来的缺省参数值

这个原则强调了在继承关系中对于缺省参数的使用和重新定义的限制。

理解条款37的关键点如下：

1. 缺省参数值的作用：在函数声明中，可以为参数提供缺省参数值，这样在调用函数时，如果没有提供相应参数的值，将使用缺省参数值作为参数的值。这使得函数调用更加灵活和简洁。

2. 缺省参数值的定义位置：缺省参数值是在函数的声明或定义中指定的，并不是在函数的调用处指定的。因此，在函数声明或定义中指定的缺省参数值在整个继承层次结构中保持不变。

3. 重新定义缺省参数值的危险性：当派生类重新定义（override）一个继承而来的带有缺省参数值的函数时，如果重新定义的函数中提供了不同的缺省参数值，会导致继承链中的函数调用出现二义性和不一致的结果。

4. 缺省参数值的使用原则：为了避免重新定义缺省参数值带来的问题，应该在继承关系中避免重新定义带有缺省参数值的函数。如果需要不同的缺省参数值，可以通过重载（overloading）或使用函数重写（function overriding）来实现。

总而言之，条款37建议避免重新定义继承而来的带有缺省参数值的函数，以防止二义性和不一致性的问题。如果需要不同的缺省参数值或参数列表，应该使用重载或函数重写的方式来实现。这样可以确保函数调用的一致性和可预测性，并遵循正确的函数重载和继承的原则。

==**请记住：**==

- ==**绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。**==

# 条款38：通过复合塑模出has-a或“根据某物实现出”

这个条款强调了使用复合而不是继承来构建对象之间的关系的重要性。

理解条款38的关键点如下：

1. 继承与复合的区别：继承是一种对象之间的关系，其中派生类继承了基类的特性和行为。而复合是一种对象之间的关系，其中一个对象包含另一个对象作为其一部分。

2. has-a关系：has-a关系表示一个对象具有另一个对象作为其一部分的关系。例如，一个汽车has-a引擎，一个公司has-a员工。这种关系通常可以通过复合来实现。

3. “根据某物实现出”关系：有时，一个类可以通过复合另一个类来实现其功能。这意味着类的实现依赖于另一个类的实现。例如，一个集合类可以“根据某物实现出”迭代器功能，即通过复合一个迭代器对象来实现迭代功能。

4. 复合的优势：相比继承，复合具有更大的灵活性和可定制性。通过复合，可以将对象之间的关系限制在需要的范围内，并避免继承链的复杂性和脆弱性。复合还可以提供更好的封装和模块化，使对象之间的依赖关系更清晰。

总而言之，条款38鼓励使用复合来构建对象之间的关系，特别是has-a关系或“根据某物实现出”关系。通过复合，可以实现更灵活、可定制和可维护的代码。继承仍然是一种有用的工具，但在设计对象之间的关系时，应该优先考虑使用复合。

==**请记住：**==

- ==**复合（composition）的意义和public继承完全不同**==
- ==**在应用域（application domain），复合意味has-a（有一个）。在实现域（implementation domain），复合意味is-implemented-in-terms-of（根据某物实现出）。**==

# 条款39：明智而审慎地使用private继承

理解条款39的关键点如下：

1. 继承关系的访问控制：C++中的继承关系可以通过不同的访问控制符（public、protected、private）来指定对基类成员的访问权限。其中，private继承将基类的成员作为派生类的私有成员。

2. private继承的含义：使用private继承意味着派生类从基类那里继承了实现细节（implementation details），而不是接口（interface）。这种继承形式用于实现派生类“is-implemented-in-terms-of”基类的关系。

3. private继承的适用情况：private继承通常用于以下情况：
	- 当派生类需要重新定义（override）基类的虚函数，以提供自己的实现。
	- 当派生类需要访问基类的保护成员，以在派生类中实现特定行为。
	- 当派生类需要实现某种特定的接口或协议，基类提供了一些实现细节，但不需要对外公开。

4. 使用private继承的注意事项：在使用private继承时，需要注意以下事项：
	- private继承并不表示“是一个”（is-a）关系，而是一种实现关系。
	- private继承不应被滥用，应该慎重考虑是否需要使用它。
	- private继承应该与组合（composition）相比较，确保选择最适合的关系来实现设计需求。

总之，条款39建议在使用private继承时要明智而审慎。它强调了private继承的特殊含义和适用情况，并提醒开发者在选择继承关系时要仔细考虑，并与组合关系进行比较和评估。正确地使用private继承可以提供灵活性和实现的便利性，同时保持良好的设计和代码的可维护性。

==**请记住：**==

- ==**Private继承意味is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）地级别低。但是当derived class 需要访问protected base class 的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。**==
- ==**和复合（composition）不同，private继承考研造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。**==

# 条款40：明智而审慎地使用多重继承

理解条款40的关键点如下：

1. 多重继承的含义：多重继承是C++中一种允许一个派生类从多个基类继承特性和行为的机制。派生类可以获得多个基类的成员和接口。
2. 多重继承的优势：多重继承可以在某些情况下提供灵活性和复用性。它可以使派生类具有不同基类的特性，以实现更丰富和复杂的功能。
3. 多重继承的适用情况：多重继承通常用于以下情况：
	- 当派生类需要从多个基类中继承不同的接口和行为时。
	- 当派生类需要在多个不相关的类之间共享代码和数据。
4. 使用多重继承的注意事项：在使用多重继承时，需要注意以下事项：
	- 显示指定基类的构造函数和析构函数。
	- 虚拟继承（virtual inheritance）可以解决菱形继承（diamond inheritance）问题。
	- 菱形继承问题（diamond inheritance problem）：当派生类通过多条路径继承同一个基类时，可能导致二义性和冗余。

正确地使用多重继承可以提供灵活性和功能复用，但也需要处理潜在的二义性和冗余问题。

**==请记住：==**

- **==多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承地需要。==**
- **==virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes 不带任何数据，将是最具使用价值的情况。==**
- **==多重继承的确有正当途径。其中一个情节涉及“public”继承某个Interface class“和”private继承某个协助实现的class“的两相结合。==**

# 条款41：了解隐式接口和编译期多态

理解条款41的关键点如下：

1. 隐式接口：隐式接口是指一个类或对象所提供的所有可用的成员函数和非成员函数，包括非虚函数、虚函数和重载函数。通过这些函数，对象向外部提供了一种使用的方式，形成了其隐式接口。

2. 编译期多态：编译期多态是通过函数重载和模板技术来实现的。在编译期间，**编译器可以根据函数的参数类型和模板实例化的类型进行静态类型推导和函数匹配，从而选择调用合适的函数。**==这种多态性在编译期间解决，不涉及运行时的动态绑定。==

3. 隐式接口和编译期多态的优势：理解隐式接口和编译期多态的概念可以提供更好的代码复用、可扩展性和可维护性。通过隐式接口，可以在不修改类定义的情况下添加新的功能和行为。通过编译期多态，可以在编译期间解决函数的调用问题，提高性能并避免运行时的开销。

4. 使用隐式接口和编译期多态：为了有效地利用隐式接口和编译期多态，应该遵循一些准则：
	- 尽量使用非成员函数，将算法和数据分离。
	- 使用函数重载来处理不同参数类型的操作。
	- 使用模板来实现通用的算法和数据结构。

# 条款42：了解typename的双重意义

理解条款42的关键点如下：

1. `typename`关键字的第一层意义：在C++模板中，当使用一个嵌套从属类型（nested dependent type）时，编译器无法确定这个从属类型是一个类型名（type name）还是一个静态成员变量（static member variable）。此时，需要使用`typename`关键字来明确告诉编译器这个从属类型是一个类型名。

2. `typename`关键字的第二层意义：在C++中，当定义模板的类型参数时，使用`typename`关键字来指定该参数是一个类型名。

3. `typename`的正确使用方式：在模板中，当使用从属类型时，如果编译器无法推断出这是一个类型名，需要使用`typename`关键字。例如：

```cpp
template<typename T>
void foo() {
    typename T::NestedType* ptr; // 使用typename指定T::NestedType是一个类型名
    // 其他代码...
}
```

4. `typename`关键字的限制：`typename`关键字只能在模板中使用，用于指定从属类型是一个类型名。在非模板代码中，不需要使用`typename`关键字。

==**请记住：**==

1. ==**声明template参数时，前缀关键字class和typename可互换。**==
2. ==**请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class 修饰符。**==

# 条款43：学习处理模板化基类内的名称

## **1、存在的问题：**

```CPP
template<typename T1>
class Class_A{
public:
	void send1(T1 var);
};

template <typename T1>
class Class_B:public Class_A< T1 >{
public:
	void send2(T1 var) { send1(var); } //编译错误，调用模板基类内函数失败
};
```

与普通继承的差别：==**在一般继承体系中，派生类可以调用基类方法，但模板继承中存在问题。**==

原因：==**由于base class template可能被特化，而特化版本可能不提供和一般性template模板相同的接口。因此编译器往往拒绝在templated base class（模板基类）内寻找继承而来的名称**==

例子：

```CPP
template<>
class Class_A<Type_1>{ //特化模板类，类型为Type_1时的模板类
public:
	void send3(Type_1 var); // 该特化类中不存在send1函数
};
```

知识点：`template<>`为特化模板标志
现象：由于特化类中不存在`send1`函数，因此派生类调用该函数失败**==。所以编译器由于知道基类模板可能被特化，使得接口不一致，所以禁止了这样的调用。==**

## **2、解决方法：**

==解决方法的原理：对编译器承诺，base class template的任何版本（包括特化版本）都将支持一般版本所提供的的接口。==

### a）使用this->

```CPP
template <typename T1>
class Class_B:public Class_A< T1 >{
public:
	void send2(T1 var) { this->send1(var); }  // 告诉编译器，假设send1被继承
};
```

### b） 使用using声明

```CPP
template <typename T1>
class Class_B:public Class_A< T1 >{
public:
	using Class_A< T1 >::send1; // 告诉编译器，send1在基类中
	void send2(T1 var) { send1(var); }  
};
```

### C） 指明被调函数所在类：基类资格修饰符

```CPP
template <typename T1>
class Class_B:public Class_A< T1 >{
public:
	void send2(T1 var) { Class_A< T1 >::send1(var); }  // 告诉编译器，send1在基类中
	// 此方法不好若send1为虚函数，则Class_A< T1 >::修饰会关闭virtual绑定行为
};
```

**==请记住：==**

1. **==可在derived class templates内通过“this->”指涉base class template内的成员名称或藉由一个明白写出的“base class 资格修饰符”完成。==**

# 条款44：将与参数无关的代码抽离templates

```CPP
template <typename T,std::size_t n>
class SquareMatrix{
public:
    ...
    void invert();
};
```

现在，考虑这些代码：

```CPP
SquareMatrix<double,5) sm1;
...
sm1.invert();

SquareMatrix<double,10> sm2;
...
sm2.invert();
```

这样将会生成两份invert，这些函数并非完全相同，因为其中一个操作的是5*5矩阵而另一个是10*10的矩阵，但除了常量5和10，两个函数的其他部分完全相同，这是templates引出代码膨胀的一个典型例子。

可以发现这两个函数完全相同，只除了一个使用5而另一个使用10，那你会怎么做？以5和10来调用这个带参数的函数，而不重复代码。下面我们来进行第一次对SquareMatrix的修改：

**策略1：**

```CPP
template <typename T>
class SquareMatrixBase{
protected:
    ...
    void invert(std::size_t matrixSize);
    ...
};
template <typename T,std::size_t n>
class SquareMatrix:private SquareMatrixBase<T>{
private:
    using SquareMatrixBase<T>::invert;

public:
    ...
    void invert(){this->invert(n);}
};
```

带参数的invert位于base class SquareMatrixBase中，和SquareMatrix一样，SquareMatrixBase也是个template，不同的是它只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化，因此对于某给定之元素对象那个类型，所有矩阵共享同一个（也是唯一一个）SquareMatrixbase class，它们也将因此共享这唯一一个class内的invert。注意这些函数中我们使用“this->”标记，因为如果不这样做，便如条款43所讲的那样，模板化基类内的函数名称会被derived class掩盖，同时我们这儿使用private继承的原因是base class SquareMatrixBase只是为了帮助derived class SquareMatrix是实现，子类和父类之间不是“is-a”关系。

**策略2：**
针对SquareMatrixBase::invert的实现，我们该如何操作呢？解决办法是让SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存，而只要它存储了这些东西，也就可能存储矩阵尺寸，如下：

```
template <typename T>
class SquareMatrixBase{
protected:
    SquareMatrixBase(std::size_t n,T* pMem):size(n),pDate(pMem){

    }
    void setDataPtr(T* ptr){pData=ptr;}
    ...
private:
    std::size_t size;
    T* pData;
};
```

这允许derived class中决定内存分配方式，这里我们针对derived class有两种分配方式：
1）存储指针数组，这样可能导致对象吱声超级大！！！

```CPP
template <typename T,std::size_t n>
class SquareMatrix:private SquareMatrixBase<T>{
public:
    SquareMatrix():SquareMtrixBase<T>(n,data){}
    ...
private:
    T data[n*n];
};
```

2）把每一个矩阵的数据放进heap中，即通过new进行动态内存分配；

```CPP
template <typename T,std::size_t n>
class SquareMatrix:private SquareMatrixBase<T>{
public:
    SquareMatrix():SquareMatrixBase<T>(n,0),pData(new T[n*n]){
    this->setDataPtr(pData.get());
    }
    ...
private:
    boost::scoped_array<T> pData;
};
```

> 1）non-type template parameters（非类型模板参数）：模板参数并不局限于类型，template <<>typename T,int n>或者template <<>typename T,size_t n>等等，第二个就是非类型模板参数！
> 2）type parameters：标准的类型模板参数，template <<>typename T>。

==**请记住：**==

1. ==**template生成多个classes和多个函数，所以任何template代码都不应该与某个造成膨胀的template参数产生相依关系；**==
2. ==**因类型模板参数（non-type template parameters）造成的代码膨胀，往往可以消除，做法是以函数参数或者class成员变量代替template参数；**==
3. ==**因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同的二进制表搜狐的具现类型共享实现码。**==

# 条款45：运用成员函数模板接受所有兼容类型

## 一、添加成员函数模板

### 以一个例子引出，何时设计成员函数模板

- **第一步：我们知道指针的一个特点就是：支持隐式转换**。
- 例如“指向non-const对象的指针可以转换为指向const对象”，“派生类指针可以隐式转换为基类指针”等等。代码如下：

```CPP
class Top {};
class Middle :public Top {};
class Bottom :public Middle {};
 
Top* pt1 = new Middle;  //将Miffle*转换为Top*
Top* pt2 = new Bottom;  //将Bottom*转换为Top*
const Top* pct2 = pt1;  //将Top*转换为const Top*
```

- **第二步：**假设现在我们设计一个模板，用来模仿智能指针类，并且希望智能指针能像普通指针一样进行类型转换。例如：

```CPP
class Top {};
class Middle :public Top {};
class Bottom :public Middle {};
 
//自己设计的智能指针类
template<typename T>
class SmartPtr
{
public:
    explicit SmartPtr(T* realPtr);
};
 
int main()
{
    //下面是我们希望能完成的，但是还没有实现
    SmartPtr<Top> pt1 = SmartPtr<Middle>(new Middle);
    SmartPtr<Top> pt2 = SmartPtr<Bottom>(new Bottom);
    SmartPtr<const Top> pct2 = pt1;
 
    return 0;
}
```

- **第三步：**根据上面的需求，我们希望让自己的智能指针类能像普通指针一样进行类型转换，那么我们可以为SmartPtr设计拷贝构造函数或拷贝赋值运算符，那么上面的功能就能实现了。
	- **一种低效的做法是：**在SmartPtr模板中针对于每一个Top派生类定义一个拷贝构造函数和拷贝赋值运算符。但是这种做法十分低效，因为针对每一个派生类设计相对应的拷贝构造函数和拷贝赋值运算符会使class膨胀，并且如果将来加入新的派生类，那么还需要继续添加新的成员函数

- **第四步：**另一种做法是：为 SmartPtr **模板添加一个成员函数模板**
	- 例如：根据下面的拷贝构造函数，我们可以对任何类型T和任何类型U，将一个SmartPtr<U>转换为SmartPtr<T> 
	- **下面的拷贝构造函数并未声明为explicit：**因为原始指针类型之间的转换是隐式转换，如果我们的模板类型为原始指针，那么要支持这种隐式转换，因为我们并未声明explicit

```CPP
template<typename T>
class SmartPtr
{
public:
    //拷贝构造函数，是一个成员函数模板
    typename<typename U>
    SmartPtr(const SmartPtr<U>& other);
};
```

- 根据上面的介绍我们可以知道，为类模板设计一个成员函数模板是为了进行统一性与间接性，避免冗余操作

## 二、约束成员函数模板的行为

- 在“一”中，我们为智能指针类设计了拷贝构造函数，这样就可以根据类型进行类型转换了

- **但是还有一些问题没有解决：**
	- 那就是，对于类继承来说，派生类指针可以转换为基类指针，但是基类指针不能转换为派生类指针
	- 类似的，对于普通类型来说，我们不能将`int*`转换为`double*`

- 因此，即使我们设计了成员函数模板，那么**还需要考虑一些转换的特殊情况**（上面列出的）

> ### 解决方法
>
> - 我们可以为自己的只能指针类提供一个类似于shared_ptr的get()成员函数，这个函数返回智能指针锁封装的那个原始指针
>
> - **设计的代码如下：**
>
> 	```cpp
> 	template<typename T>
> 	class SmartPtr
> 	{
> 	public:
> 	    typename<typename U>
> 	    SmartPtr(const SmartPtr<U>& other)
> 	        :heldPtr(other.get())
> 	    T get()const {
> 	        return heldPtr;
> 	    }
> 	private:
> 	    T* heldPtr;
> 	};
> 	```
>
> - **此处设计的原理：**
>
> 	- get()成员函数返回原始指针
> 	- 在拷贝构造函数中，我们使用了成员初始化列表来进行初始化智能指针封装的原始指针
> 	- 因此，在拷贝构造函数的构造过程中，是根据原始指针进行转换的，因此如果原始指针会自己判断这种转换行为：如果可以转换，那么拷贝构造函数就正确执行；如果不能转换，那么拷贝构造函数出错

## 三、设计赋值成员函数模板

- 我们上面设计的智能指针模板不限于构造函数，而且还可以自己设计赋值操作

> ### 演示说明
>
> - **例如shared_ ptr：**
> 	- 支持所有“来自内置指针、shared_ptr、auto_ptr、weak_ptr”的构造函数
> 	- 支持上面所有（出去weak_ptr）的赋值操作
> - **例如下面是shared_ptr的源码摘录：**（其中template参数强烈倾向使用class而不是typename）
>
> ```CPP
> template<class T>
> class shared_ptr
> {
> public:
>     //下面都是拷贝构造函数(列出了一部分)
>     template<class Y>
>     explicit shared_ptr(Y* p);
>     template<class Y>
>     shared_ptr(shared_ptr<Y> const& r);
>     template<class Y>
>     explicit shared_ptr(weak_ptr<Y> const& r);
>     template<class Y>
>     explicit shared_ptr(auto_ptr<Y>& r);
> 
>     //下面都是赋值操作(列出了一部分)
>     template<class Y>
>     shared_ptr& operator=(shared_ptr<Y> const& r);
>     template<class Y>
>     shared_ptr& operator=(auto_ptr<Y>& r);
> };
> ```
>
> - **代码说明：**
> 	- 构造函数：都是explicit，除了“泛化copy构造函数”除外。因为从某个shared_ptr类型隐式转换为另一个shared_ptr是被允许的，但是从某个内置指针或从其他智能指针进行隐式转换为shared_ptr是不被允许的（除了使用cast进行强制类型转换）
> 	- auto_ptr：参数为auto_ptr的拷贝构造函数和赋值运算符，其参数都不是const的（条款13说过，当你赋值一个auto_ptr时，我们希望其所管理的对象被移动改动）

## 四、与默认函数的区别

- 我们曾说过，一个类如果没有提供构造函数、拷贝构造函数、拷贝赋值运算符，那么编译器会自动为类提供合成/默认的版本，这一规则同样适用于模板类
- 因此，例如我们上面为自己的类添加了成员函数模板（拷贝构造函数），那么当我们使用拷贝构造函数的时候是调用哪一个版本呢？答案为：根据实际调用情况选择
- 因此，如果我们自己设计成员函数模板还需要拷贝类为我们自己提供的合成版本，在必要时自己设计非成员函数模板
- 例如，下面是shared_ptr的源码摘录：

```CPP
template<class T>
class shared_ptr
{
public:
    //拷贝构造函数
    shared_ptr (shared_ptr const& r);   //非泛化版本
    template<class Y>
    shared_ptr(shared_ptr<Y> const& r); //泛化版本
 
    //拷贝赋值运算符
    shared_ptr& operator=(shared_ptr const& r);    //非泛化版本
    template<class Y>
    shared_ptr& operator=(shared_ptr<Y> const& r); //泛化版本
};
```

## 五、总结

==**请记住：**==

- ==**请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数**==
- ==**如果你生命member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符**==

# 条款46：需要类型转换时请为模板定义非成员函数

首先为什么类似于operator 这样的重载运算符要定义成非成员函数，主要是为了保证混合乘法2 Variant或者Variant * 2都可以通过编译，但是2不能同时进行隐式类型转换成某个Variant，再作this用。

所以我们一般将之定义成友元函数，像下面这样：

```CPP
class Variant
{
public:
    Variant(const int& value = 0) {}
 
    friend const Variant operator* (const Variant&lhs, const Variant& rhs);
};
 
const Variant operator* (const Variant&lhs, const Variant& rhs) 
{
    return Variant();
}
 
//使用方式
Variant val(1);             //ok
Variant result = val * 1;   //ok
result = 2 * val;           //ok
```

现在引入模板，可以像下面这样写，注意这里的operator*是一个独立的模板函数：

```CPP
template<typename T>
class Variant
{
public:
    Variant(const T& value = 0) {}
};
 
template<typename T>
const Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs)
{
    return Variant<T>();
}
```

但是这次不能通过编译并且在vs2015下的报错信息：

```CPP
C2784   “const Variant<T> operator *(const Variant<T> &,const Variant<T> &)”: 未能从“int”为“const Variant<T> &”推导 模板 参数 
```

原因是编译器推导T出现了困难，val * 1在编译器看来，可以由a是Variant将T推导成int，但是1是什么，理想情况下编译器会尝试将它先转换成一个Variant，并将T推导成int，但事实上编译器在“T推导过程中从不将隐式类型转换函数纳入考虑”。所以无论是val * 1还是1 * val 都是不能通过编译的，一句话，隐式转换+推导T不能被同时被编译器接受。

解决问题的思路便接着产生，编译器既然不能同时接受这两个过程，就让它们事先满足好一个条件，再由编译器执行另一个过程好了。

如果把这个operator*放在template class里面，也就是先在生成模板类的那一步就定下T，这样编译器只要执行隐式转换这一步就可以了。

因此我们可以这样来改：

```CPP
template<typename T>
class Variant
{
public:
    Variant(const T& value = 0) {}
 
    friend const Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs);
};
```

在类中加一个友元。

我们添加了一个友元函数的声明，果然编译通过了，但链接时又报错了，**原因是链接器找不到operator\*的定义，这里又要说模板类中的一个特殊情况了，它不同与普通的类，模板类的友元函数只能在类中实现，所以要把函数体部分移至到类内，像下面这样：**

```CPP
template<typename T>
class Variant
{
public:
    Variant(const T& value = 0) {}
 
    friend const Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs)
    {
        return Variant<T>();
    }
};
```

这下编译和链接都没有问题了。这里还要说一下，就是移至类内后，T的标识符可以不写了。

operator*里面只有一句话，但如果friend函数里面的东西太多了，可以定义一个辅助方法，比如Doxxx()，这个Doxxx可以放在类外去实现，Doxxx本身不支持混合乘法（2 * Variant或者Variant* 2），但由于在operator*里面已经进行了隐式类型转换，所以到Doxxx()这一级是没有问题的。

==**请记住：**==

- ==**当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。**==

# 条款47:请使用traits classes表现类型信息

## 1、如果想写一个将迭代器移动d单位的函数

```CPP
template<template IterT,typename DistT>
void advance(IterT& iter,DistT d);//d>0前移，d<0后移
```

具体过程该怎么写呢？直接写 iter += d 是行不通的，因为这种只有random acces（随机访问）迭代器才支持+=的操作，而其他威力不那么强大的迭代器种类，advance必须反复施行 ++ 或 --，共d次。

## 2、STL迭代器一共有5类

- input迭代器：**只能向前移动，一次一步，只能读取。**例如，模仿指向输入文件的读指针(read pointer)。C++程序库中的`istream_iterators`是这一分类的代表。

- Output迭代器：**只能向前移动，一次一步，只能写。**例如，模仿指向输出文件的写指针(write pointer)。C++程序库中的`ostream_iterators`是这一分类的代表。

> 以上两种迭代器是威力最小的两个迭代器分类。因为一次只能一步，所以它们只适合“一次性操作算法”

- forward迭代器：**可以做前述两种迭代器所能做的每一件事，而且可以读写其所指物一次以上，**因此可施行于“多次性操作算法”，TR1 hashed容器可能是这一分类**（这里说“可能”是因为hashed容器的迭代器可为单向也可为双向，取决于实现版本）。**

- Bidirectional迭代器：**除了可前移还可后移。**STL的list迭代器就属于这一分类，set，multiset，map和multimap的迭代器也都是这一分类。

- random access迭代器：**威力最大的迭代器，可以执行“迭代器算术”，因此可在常量时间内前后随机移动任意的距离。**vector，deque和string提供的迭代器都是这一分类。有时内置指针也可被当做random access 迭代器使用。

对于这5类，C++标准库分别提供tag struct（卷标结构）加以确认

```CPP
struct input_iterator_tag{};
struct output_iterator_tag{};
struct forward_iterator_tag :public input_iterator_tag{};
struct bidirectional_iterator_tag :public forward_iterator_tag{};
struct random_access_iterator_tag :public bidirectional_iterator_tag{};
```

在写advance函数时前4类迭代器可以使用++，--，而最后一个可以使用iter+=d,所以我们就需要在编译期取得类型信息，知道是哪一种迭代器.

## 3、解决方式就是利用iterator_traits

`template<typename IterT> struct iterator_traits;`//template,用来处理迭代器分类的相关信息

iterator_traits的运作方式是，针对每一个IterT,在`struct iterator_traits<IterT>`内一定声明某个typedef名为`iterator_category`。这个typedef用来确认IterT的迭代器分类。即首先要求用户自定义的迭代器类型必须嵌套一个typedef，名为`iterator_category`,用来确认适当的卷标结构

例如

```CPP
template<...>
class deque{
public:
	class iterator{
	public:
		typedef random_access_iterator_tag iterator_category;
	};
};
```

iterator_traits只是响应iterator class的嵌套式typedef

```CPP
template<typename IterT>
struct iterator_traits{
	typedef typename IterT::iterator_category iterator_category;
};
//针对指针,偏特化
template<typename IterT>
struct iterator_traits<IterT*>{
	typedef typename IterT::iterator_category iterator_category;
};
```

迭代器移动函数可这样实现

```CPP
template<typename IterT,typename DistT>
void doAdvance(IterT& iter, DistT d, std::bidirectional_iterator_tag)
{
	if (d >= 0) 
	{
		while (d--)
			++iter;
	}
	else
	{
		while (d++)
			--iter;
	}
}
template<typename IterT, typename DistT>
void doAdvance(IterT& iter, DistT d, std::input_iterator_tag)
{
	if (d < 0)
		throw std::out_of_range("Negative distance");
	while(d--) ++iter;
}
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d)
{
	doAdvance(iter, d, typename std::iterator_traits<IterT>::iterator_category);
}
```

==**请记住**==

- ==**Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现**==
- ==**整合重载技术后，traits classes有可能在编译期对类型执行if...else测试**==

# 条款48：认识template元编程

## 1、内容

1. template metaprogramming（TMP，模板元编程）是：编写 template C++ 程序并执行于编译期的过程。所谓模板元程序就是：以 C++ 写成，执行于 C++ 编译器内的程序。该程序执行后产生具现的代码，和正常代码一并加入编译。也就说元编程可以做到用代码去生成代码。

2. TMP 伟大之处在于，由于 template metaprograms 执行于 C++ 编译期，因此可以将很多工作从运行期转移到编译期。例如：

	- 某些错误原本通常在运行期才能检测到，现在可在编译器找出来。

	- 使用 TMP 的 C++ 程序可能在每一方面都更加高效：比如较小的可执行文件，较短的运行期，较少的内存需求。

3. 在条款 47 我们曾提到如何实现一个 Move 函数：

	```CPP
	template <typename IteratorType>
	void Move(IteratorType& Iterator, int Distance) {
	    // 使用类型信息
	    if (typeid(IteratorTraits<IteratorType>::IteratorTag) == typeid(RandomAccessIteratorTag)) {   
	        Iterator += Distance;
	    }
	    else {
	        if (Distance >= 0) {
	            while (Distance--)++Iterator;
	        }
	        else {
	            while (Distance++)--Iterator;
	        }
	    }
	}
	```

	并且我们曾描述这可能存在编译问题，现在就让我们看看是什么：虽然我们这里根据迭代器类型进行不同的操作，或 +=，或 ++，–，我们知道只有 Random Access Iterator 可以有 += 运算，但是 C++ 要求：编译器必须确保所有源码都有效，即使是不会执行的源码。也就是说编译器会拿着其他不支持 += 的迭代器，进入 if 语句先测试是否支持 += 运算，无效则会报错。

	所以相比于要支持所有操作，Traits class 针对不同类型进行函数重载的做法显然更好。

4. 我们先简单了解一下 TMP 编程。TMP 已被证明是一个图灵完备（Turing-complete）机器，这意味着它可以计算任何事物，使用 TMP 你可以声明变量，执行循环，编写及调用函数…但这些相对于正常的 C++ 的实现会有很大的不同。比如：TMP 并没有循环部件，所有的循环效果都由递归完成。如果你不了解递归，恐怕必须先解决这个问题。

5. 一个经典的入门案例是使用 TMP 计算阶乘：

	```cpp
	template <unsigned N>
	struct Factorial {
	    static const int Value = N * Factorial<N - 1>::Value;
	};
	
	template <>
	struct Factorial<0> {
	    static const int Value = 1;
	};
	
	inline void TryWithFactorial() {
	    std::cout << Factorial<10>::Value << "\n";
	}
	```

	和所有递归行为一样，我们需要一个特殊情况来结束递归。对于 TMP 而言就是使用 template 的特化版本。

	正如 TryWithFactorial 函数所使用的，只要你声明`Factorial<N>::Value` 就可以得到 N 阶乘值。当然这里存在值溢出的问题。

6. TMP 目前是一个新生的技术，语法不直观，也缺少 template 相关的调试器，但它将运行期工作移至编译期所带来的效率提升还是很令人印象深刻。

## 2、 总结

==**请记住：**==

- ==**Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。**==
- ==**TMP 可被用来生成基于政策选择组合（based on combination of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。**==
